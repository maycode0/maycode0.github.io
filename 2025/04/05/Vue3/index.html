<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="记录Vue3学习">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue3使用手册">
<meta property="og:url" content="http://example.com/2025/04/05/Vue3/index.html">
<meta property="og:site_name" content="May&#39;Blog">
<meta property="og:description" content="记录Vue3学习">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-04-05T03:50:08.000Z">
<meta property="article:modified_time" content="2025-04-08T11:31:07.000Z">
<meta property="article:author" content="May">
<meta property="article:tag" content="Vue3">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/04/05/Vue3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/04/05/Vue3/","path":"2025/04/05/Vue3/","title":"Vue3使用手册"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Vue3使用手册 | May'Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">May'Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">项目开发过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">技术选型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA-vue-%E7%8E%AF%E5%A2%83"><span class="nav-number">1.2.</span> <span class="nav-text">构建 vue 环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA"><span class="nav-number">1.3.</span> <span class="nav-text">vue 项目创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E7%BB%84%E4%BB%B6"><span class="nav-number">1.3.1.</span> <span class="nav-text">根组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%82%E8%BD%BD%E5%BA%94%E7%94%A8"><span class="nav-number">1.3.2.</span> <span class="nav-text">挂载应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95"><span class="nav-number">1.4.</span> <span class="nav-text">模板语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E6%8F%92%E5%80%BC"><span class="nav-number">1.4.1.</span> <span class="nav-text">文本插值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B-html"><span class="nav-number">1.4.2.</span> <span class="nav-text">原始 html</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Attribute-%E7%BB%91%E5%AE%9A"><span class="nav-number">1.4.3.</span> <span class="nav-text">Attribute 绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%BB%91%E5%AE%9A"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">在组件上使用类型绑定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%86%85%E6%95%9B%E6%A0%B7%E5%BC%8F"><span class="nav-number">1.4.4.</span> <span class="nav-text">绑定内敛样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E5%88%97%E8%A1%A8"><span class="nav-number">1.4.5.</span> <span class="nav-text">渲染列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="nav-number">1.4.6.</span> <span class="nav-text">条件渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.4.7.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8"><span class="nav-number">1.4.8.</span> <span class="nav-text">模板引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E7%A1%80"><span class="nav-number">1.5.</span> <span class="nav-text">响应式基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%B1%82%E5%93%8D%E5%BA%94%E6%80%A7"><span class="nav-number">1.5.1.</span> <span class="nav-text">深层响应性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="nav-number">1.6.</span> <span class="nav-text">计算属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%BC%93%E5%AD%98-vs-%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.1.</span> <span class="nav-text">计算属性缓存 vs 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%86%99%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="nav-number">1.6.2.</span> <span class="nav-text">可写计算属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A"><span class="nav-number">1.7.</span> <span class="nav-text">表单输入绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-number">1.8.</span> <span class="nav-text">监听器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6"><span class="nav-number">1.9.</span> <span class="nav-text">组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E6%A7%BD"><span class="nav-number">1.9.1.</span> <span class="nav-text">插槽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6"><span class="nav-number">1.9.2.</span> <span class="nav-text">动态组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#props"><span class="nav-number">1.9.3.</span> <span class="nav-text">props</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TS-%E8%A7%A3%E6%9E%84%E8%AF%AD%E6%B3%95"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">TS 解构语法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6-1"><span class="nav-number">1.9.4.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.9.4.1.</span> <span class="nav-text">组件事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%A0%A1%E9%AA%8C"><span class="nav-number">1.9.4.2.</span> <span class="nav-text">事件校验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6-v-model"><span class="nav-number">1.9.5.</span> <span class="nav-text">组件 v-model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%8F%E4%BC%A0%E5%B1%9E%E6%80%A7"><span class="nav-number">1.9.6.</span> <span class="nav-text">透传属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A6%81%E7%94%A8%E9%80%8F%E4%BC%A0%E5%B1%9E%E6%80%A7"><span class="nav-number">1.9.6.1.</span> <span class="nav-text">禁用透传属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%A0%B9%E8%8A%82%E7%82%B9%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="nav-number">1.9.6.2.</span> <span class="nav-text">多根节点继承问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-number">1.9.7.</span> <span class="nav-text">依赖注入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E7%90%86%E8%A7%A3"><span class="nav-number">1.10.</span> <span class="nav-text">闭包理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise"><span class="nav-number">1.11.</span> <span class="nav-text">Promise</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pinia-%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="nav-number">1.12.</span> <span class="nav-text">Pinia 全局状态管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-Router"><span class="nav-number">1.13.</span> <span class="nav-text">Vue Router</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="May"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">May</p>
  <div class="site-description" itemprop="description">泛舟</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    

  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/05/Vue3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="May">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="May'Blog">
      <meta itemprop="description" content="泛舟">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Vue3使用手册 | May'Blog">
      <meta itemprop="description" content="记录Vue3学习">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Vue3使用手册
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-05 11:50:08" itemprop="dateCreated datePublished" datetime="2025-04-05T11:50:08+08:00">2025-04-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-08 19:31:07" itemprop="dateModified" datetime="2025-04-08T19:31:07+08:00">2025-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

            <div class="post-description">记录Vue3学习</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="项目开发过程"><a href="#项目开发过程" class="headerlink" title="项目开发过程"></a>项目开发过程</h1><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p><strong>vue3+typescript</strong></p>
<p><strong>vite 构建，打包</strong></p>
<p><strong>axios 网络请求</strong></p>
<p><strong>ant design for vue 组件库</strong></p>
<p><strong>pinia 全局状态管理</strong></p>
<p><strong>mock 技术</strong></p>
<h2 id="构建-vue-环境"><a href="#构建-vue-环境" class="headerlink" title="构建 vue 环境"></a>构建 vue 环境</h2><p><strong>通过脚手架创建 vue 环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vue@latest</span><br></pre></td></tr></table></figure>

<p><strong>通过以下步骤安装依赖并启动开发服务器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;your-project-name&gt;</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<h2 id="vue-项目创建"><a href="#vue-项目创建" class="headerlink" title="vue 项目创建"></a>vue 项目创建</h2><p>**每个 Vue 应用都是通过 **<a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/application.html#createapp"><code>createApp</code></a> 函数创建一个新的 <strong>应用实例</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const app = createApp(&#123;</span><br><span class="line">  /* 根组件选项 */</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="根组件"><a href="#根组件" class="headerlink" title="根组件"></a>根组件</h3><p>**我们传入 **<code>createApp</code> 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。</p>
<p><strong>如果你使用的是单文件组件，我们可以直接从另一个文件中导入根组件。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">// 从一个单文件组件中导入根组件</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line"></span><br><span class="line">const app = createApp(App)</span><br></pre></td></tr></table></figure>

<p><strong>虽然本指南中的许多示例只需要一个组件，但大多数真实的应用都是由一棵嵌套的、可重用的组件树组成的。例如，一个待办事项 (Todos) 应用的组件树可能是这样的：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">App (root component)</span><br><span class="line">├─ TodoList</span><br><span class="line">│  └─ TodoItem</span><br><span class="line">│     ├─ TodoDeleteButton</span><br><span class="line">│     └─ TodoEditButton</span><br><span class="line">└─ TodoFooter</span><br><span class="line">   ├─ TodoClearButton</span><br><span class="line">   └─ TodoStatistics</span><br></pre></td></tr></table></figure>

<h3 id="挂载应用"><a href="#挂载应用" class="headerlink" title="挂载应用"></a>挂载应用</h3><p>**应用实例必须在调用了 **<code>.mount()</code> 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- xxx.html --&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// .ts</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>

<p>**应用根组件的内容将会被渲染在容器元素里面。容器元素自己将****不会**被视为应用的一部分。</p>
<p>**当根组件没有设置 **<code>template</code> 选项时，Vue 将自动使用容器的 <code>innerHTML</code> 作为模板。</p>
<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="文本插值"><a href="#文本插值" class="headerlink" title="文本插值"></a>文本插值</h3><p><strong>最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 (即双大括号)：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p><strong>双大括号标签会被替换为相应组件实例中 msg 属性的值。同时每次 msg 属性更改时它也会同步更新。</strong></p>
<h3 id="原始-html"><a href="#原始-html" class="headerlink" title="原始 html"></a>原始 html</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const rawHtml: string =</span><br><span class="line">  &#x27;&lt;span style=&quot;color: red&quot;&gt;This should be red.&lt;/span&gt;&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Using text interpolation: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p><strong>页面渲染为:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Using text interpolation: `&lt;span style=&quot;color: red&quot;&gt;`This should be red.</span><br><span class="line"></span><br><span class="line">Using v-html directive: This should be red.</span><br></pre></td></tr></table></figure>

<h3 id="Attribute-绑定"><a href="#Attribute-绑定" class="headerlink" title="Attribute 绑定"></a>Attribute 绑定</h3><p>**双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 **<code>v-bind</code> 指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-bind</code> 指令指示 Vue 将元素的 <code>id</code> attribute 与组件的 <code>dynamicId</code> 属性保持一致。如果绑定的值是 <code>null</code> 或者 <code>undefined</code>，那么该 attribute 将会从渲染的元素上移除。</p>
<p><strong>简写</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 与 :id=&quot;id&quot; 相同 --&gt;</span><br><span class="line">&lt;div :id&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>动态绑定类标签</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// .ts</span><br><span class="line">const isActive = ref(true)</span><br><span class="line">const hasError = ref(false)</span><br><span class="line">// .html</span><br><span class="line">&lt;div</span><br><span class="line">  class=&quot;static&quot;</span><br><span class="line">  :class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span><br><span class="line">&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>渲染的结果为：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>也可直接用一个完整对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// .ts</span><br><span class="line">const classObject = reactive(&#123;</span><br><span class="line">  active: true,</span><br><span class="line">  &#x27;text-danger&#x27;: false</span><br><span class="line">&#125;)</span><br><span class="line">// .html</span><br><span class="line">&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>渲染结果与上面相同</strong></p>
<h4 id="在组件上使用类型绑定"><a href="#在组件上使用类型绑定" class="headerlink" title="在组件上使用类型绑定"></a>在组件上使用类型绑定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 子组件模板 --&gt;</span><br><span class="line">&lt;p class=&quot;foo bar&quot;&gt;Hi!&lt;/p&gt;</span><br><span class="line">&lt;!-- 在使用组件时 --&gt;</span><br><span class="line">&lt;MyComponent class=&quot;baz boo&quot; /&gt;</span><br><span class="line">&lt;!--渲染出的 HTML 为：--&gt;</span><br><span class="line">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi!&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h3 id="绑定内敛样式"><a href="#绑定内敛样式" class="headerlink" title="绑定内敛样式"></a>绑定内敛样式</h3><p><strong>绑定对象</strong><br><code>:style</code>支持绑定 JavaScript 对象值，对应的是 HTML 元素的 <code>style</code>属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const activeColor = ref(&#x27;red&#x27;)</span><br><span class="line">const fontSize = ref(30)</span><br></pre></td></tr></table></figure>

<p><strong>你可以对一个样式属性提供多个 (不同前缀的) 值，举例来说：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>**数组仅会渲染浏览器支持的最后一个值。在这个示例中，在支持不需要特别前缀的浏览器中都会渲染为 **<code>display: flex</code>。</p>
<h3 id="渲染列表"><a href="#渲染列表" class="headerlink" title="渲染列表"></a>渲染列表</h3><p>**在 Vue 中，当使用 **<code>v-for</code> 渲染列表时，必须为每个迭代的元素绑定一个唯一的 <strong><code>key</code></strong> 属性。ESLint 的 <code>vue/require-v-for-key</code> 规则会强制检查这一点，目的是确保 Vue 的虚拟 DOM Diff 算法能正确识别和高效更新节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">  &#123;&#123; item.id &#125;&#125;:&#123;&#123; item.message &#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p><code>v-if</code> 、<code>v-else-if</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;</span><br><span class="line">  B</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Not A/B/C</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>这里，</strong><code>v-if</code> 指令会基于表达式 <code>seen</code> 的值的真假来移除&#x2F;插入该 <code>&lt;p&gt;</code> 元素。</p>
<p>**你也可以使用 **<code>v-else</code> 为 <code>v-if</code> 添加一个“else 区块”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;awesome = !awesome&quot;&gt;Toggle&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-else</code> 和 <code>v-else-if</code> 也可以在 <code>&lt;template&gt;</code> 上使用。</p>
<p><code>v-show</code></p>
<p>**不同之处在于 **<code>v-show</code> 会在 DOM 渲染中保留该元素；<code>v-show</code> 仅切换了该元素上名为 <code>display</code> 的 CSS 属性。</p>
<p><code>v-show</code> 不支持在 <code>&lt;template&gt;</code> 元素上使用，也不能和 <code>v-else</code> 搭配使用。</p>
<p><code>v-show</code> VS <code>v-if</code></p>
<p><code>v-if</code> 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。</p>
<p><code>v-if</code> 也是<strong>惰性</strong>的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。</p>
<p><strong>相比之下，</strong><code>v-show</code> 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS <code>display</code> 属性会被切换。</p>
<p><strong>总的来说，</strong><code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 <code>v-show</code> 较好；如果在运行时绑定条件很少改变，则 <code>v-if</code> 会更合适。</p>
<blockquote>
<p>**当 **<code>v-if</code> 和 <code>v-for</code> 同时存在于一个元素上的时候，<code>v-if</code> 会首先被执行。</p>
</blockquote>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><code>v-on</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 简写 --&gt;</span><br><span class="line">&lt;a @click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-on</code> 指令，它将监听 DOM 事件</p>
<h3 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h3><p><strong>看上去像是自定义模板的 id</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, useTemplateRef, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const list = ref([</span><br><span class="line">  /* ... */</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">// 获取模板ref为items的dom元素</span><br><span class="line">const itemRefs = useTemplateRef(&#x27;items&#x27;)</span><br><span class="line">// 当模板被加载时打印获取的dom元素</span><br><span class="line">onMounted(() =&gt; console.log(itemRefs.value))</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">	&lt;!-- 给模板加ref标签 --&gt;</span><br><span class="line">    &lt;li v-for=&quot;item in list&quot; ref=&quot;items&quot;&gt;</span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p><strong>……</strong></p>
<h2 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h2><p><strong>声明响应式状态</strong></p>
<p>**在组合式 API 中，推荐使用 **<a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-core.html#ref"><code>ref()</code></a> 函数来声明响应式状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const count = ref(0)</span><br></pre></td></tr></table></figure>

<p><code>ref()</code> 接收参数，并将其包裹在一个带有 <code>.value</code> 属性的 ref 对象中返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const count = ref(0)</span><br><span class="line"></span><br><span class="line">console.log(count) // &#123; value: 0 &#125;</span><br><span class="line">console.log(count.value) // 0</span><br><span class="line"></span><br><span class="line">count.value++</span><br><span class="line">console.log(count.value) // 1</span><br></pre></td></tr></table></figure>

<p><strong>注意，在模板中使用 ref 时，我们不需要附加 .value。为了方便起见，当在模板中使用时，ref 会自动解包 。</strong></p>
<h3 id="深层响应性"><a href="#深层响应性" class="headerlink" title="深层响应性"></a>深层响应性</h3><p><strong>Ref 可以持有任何类型的值，包括深层嵌套的对象、数组或者 JavaScript 内置的数据结构</strong></p>
<p><strong>Ref 会使它的值具有深层响应性。这意味着即使改变嵌套对象或数组时，变化也会被检测到：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const obj = ref(&#123;</span><br><span class="line">  nested: &#123; count: 0 &#125;,</span><br><span class="line">  arr: [&#x27;foo&#x27;, &#x27;bar&#x27;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function mutateDeeply() &#123;</span><br><span class="line">  // 以下都会按照期望工作</span><br><span class="line">  obj.value.nested.count++</span><br><span class="line">  obj.value.arr.push(&#x27;baz&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>也可以通过 shallow ref 来放弃深层响应性。对于浅层 ref，只有 .value 的访问会被追踪。浅层 ref 可以用于避免对大型数据的响应性开销来优化性能、或者有外部库管理其内部状态的情况。</strong></p>
<hr>
<p>**还有另一种声明响应式状态的方式，即使用 **<code>reactive()</code> API。与将内部值包装在特殊对象中的 ref 不同，<code>reactive()</code> 将使对象本身具有响应性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const state = reactive(&#123; count: 0 &#125;)</span><br></pre></td></tr></table></figure>

<p><code>reactive()</code> 的局限性</p>
<p><strong>1.有限的值类型：它只能用于对象类型 (对象、数组和如 Map、Set 这样的集合类型)。它不能持有如 string、number 或 boolean 这样的原始类型。</strong></p>
<p><strong>2.不能替换整个对象：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失：</strong></p>
<p><strong>3.对解构操作不友好：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let state = reactive(&#123; count: 0 &#125;)</span><br><span class="line"></span><br><span class="line">// 上面的 (&#123; count: 0 &#125;) 引用将不再被追踪</span><br><span class="line">// (响应性连接已丢失！)</span><br><span class="line">state = reactive(&#123; count: 1 &#125;)</span><br><span class="line"></span><br><span class="line">const state = reactive(&#123; count: 0 &#125;)</span><br><span class="line"></span><br><span class="line">// 当解构时，count 已经与 state.count 断开连接</span><br><span class="line">let &#123; count &#125; = state</span><br><span class="line">// 不会影响原始的 state</span><br><span class="line">count++</span><br><span class="line"></span><br><span class="line">// 该函数接收到的是一个普通的数字</span><br><span class="line">// 并且无法追踪 state.count 的变化</span><br><span class="line">// 我们必须传入整个对象以保持响应性</span><br><span class="line">callSomeFunction(state.count)</span><br></pre></td></tr></table></figure>

<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>**推荐使用****计算属性**来描述依赖响应式状态的复杂逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, computed &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const author = reactive(&#123;</span><br><span class="line">  name: &#x27;John Doe&#x27;,</span><br><span class="line">  books: [</span><br><span class="line">    &#x27;Vue 2 - Advanced Guide&#x27;,</span><br><span class="line">    &#x27;Vue 3 - Basic Guide&#x27;,</span><br><span class="line">    &#x27;Vue 4 - The Mystery&#x27;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 一个计算属性 ref</span><br><span class="line">const publishedBooksMessage = computed(() =&gt; &#123;</span><br><span class="line">  return author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;Has published books:&lt;/p&gt;</span><br><span class="line">  &lt;span&gt;&#123;&#123; publishedBooksMessage &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p><strong>我们在这里定义了一个计算属性 publishedBooksMessage。computed() 方法期望接收一个 getter 函数，返回值为一个计算属性 ref。和其他一般的 ref 类似，你可以通过 publishedBooksMessage.value 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 .value。</strong></p>
<p>**Vue 的计算属性会自动追踪响应式依赖。它会检测到 **<code>publishedBooksMessage</code> 依赖于 <code>author.books</code>，所以当 <code>author.books</code> 改变时，任何依赖于 <code>publishedBooksMessage</code> 的绑定都会同时更新。</p>
<h3 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; calculateBooksMessage() &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p><strong>你可能注意到我们在表达式中像这样调用一个函数也会获得和计算属性相同的结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 组件中</span><br><span class="line">function calculateBooksMessage() &#123;</span><br><span class="line">  return author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于 ****计算属性值会基于其响应式依赖被缓存** 。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 <code>author.books</code> 不改变，无论多少次访问 <code>publishedBooksMessage</code> 都会立即返回先前的计算结果，而不用重复执行 getter 函数。</p>
<p>**这也解释了为什么下面的计算属性永远不会更新，因为 **<code>Date.now()</code> 并不是一个响应式依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const now = computed(() =&gt; Date.now())</span><br></pre></td></tr></table></figure>

<p>**相比之下，方法调用****总是**会在重渲染发生时再次执行函数。</p>
<p><strong>为什么需要缓存呢？如果没有缓存，多次调用一个庞大的数据是非常消耗内存资源的。</strong></p>
<h3 id="可写计算属性"><a href="#可写计算属性" class="headerlink" title="可写计算属性"></a>可写计算属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computer(&#123;</span><br><span class="line">get() &#123;</span><br><span class="line">// getter方法实现</span><br><span class="line">// return</span><br><span class="line">&#125;</span><br><span class="line">set()&#123;</span><br><span class="line">// setter方法实现</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>**计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说， ****不要改变其他状态、在 getter 中做异步请求或者更改 DOM** ！</p>
<p><strong>从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。</strong></p>
<h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><p><strong>在前端处理表单时，我们常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。手动连接值绑定和更改事件监听器可能会很麻烦：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  :value=&quot;text&quot;</span><br><span class="line">  @input=&quot;</span><br><span class="line">    (event) =&gt;</span><br><span class="line">      (text = (event.target as HTMLInputElement).value)</span><br><span class="line">  &quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-model</code> 指令帮我们简化了这一步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;text&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p><strong>当某一变量值发生改变，在每次响应式状态发生变化时触发回调函数。</strong></p>
<p><code>watch</code> 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const x = ref(0)</span><br><span class="line">const y = ref(0)</span><br><span class="line"></span><br><span class="line">// 单个 ref</span><br><span class="line">watch(x, (newX) =&gt; &#123;</span><br><span class="line">  console.log(`x is $&#123;newX&#125;`)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// getter 函数</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; x.value + y.value,</span><br><span class="line">  (sum) =&gt; &#123;</span><br><span class="line">    console.log(`sum of x + y is: $&#123;sum&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 多个来源组成的数组</span><br><span class="line">watch([x, () =&gt; y.value], ([newX, newY]) =&gt; &#123;</span><br><span class="line">  console.log(`x is $&#123;newX&#125; and y is $&#123;newY&#125;`)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意，你不能直接侦听响应式对象的属性值，例如:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj = reactive(&#123; count: 0 &#125;)</span><br><span class="line"></span><br><span class="line">// 错误，因为 watch() 得到的参数是一个 number</span><br><span class="line">watch(obj.count, (count) =&gt; &#123;</span><br><span class="line">  console.log(`Count is: $&#123;count&#125;`)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>这里需要用一个返回该属性的 getter 函数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 提供一个 getter 函数</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; obj.count,</span><br><span class="line">  (count) =&gt; &#123;</span><br><span class="line">    console.log(`Count is: $&#123;count&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>**默认状态 **<code>watch</code>会创建一个深层次监听对象，使用 <code>&#123;deep:true&#125;</code>显示创建深层次 <code>watch</code></p>
<p><code>watchEffect()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const todoId = ref(1)</span><br><span class="line">const data = ref(null)</span><br><span class="line"></span><br><span class="line">watch(</span><br><span class="line">  todoId,</span><br><span class="line">  async () =&gt; &#123;</span><br><span class="line">    const response = await fetch(</span><br><span class="line">      `https://jsonplaceholder.typicode.com/todos/$&#123;todoId.value&#125;`</span><br><span class="line">    )</span><br><span class="line">    data.value = await response.json()</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; immediate: true &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>**可以使用 **<code>watchEffect()</code>简写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(async () =&gt; &#123;</span><br><span class="line">  const response = await fetch(</span><br><span class="line">    `https://jsonplaceholder.typicode.com/todos/$&#123;todoId.value&#125;`</span><br><span class="line">  )</span><br><span class="line">  data.value = await response.json()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>**每当 **<code>todoId.value</code> 变化时，回调会再次执行。有了 <code>watchEffect()</code>，我们不再需要明确传递 <code>todoId</code> 作为源值。</p>
<p><strong>对于这种只有一个依赖项的例子来说，</strong><code>watchEffect()</code> 的好处相对较小。但是对于有多个依赖项的侦听器来说，使用 <code>watchEffect()</code> 可以消除手动维护依赖列表的负担。此外，如果你需要侦听一个嵌套数据结构中的几个属性，<code>watchEffect()</code> 可能会比深度侦听器更有效，因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。</p>
<p><strong>另外，</strong><code>watchEffect()</code>会立刻执行一次。</p>
<hr>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><strong>注册组件</strong></p>
<p><strong>组件名格式：</strong><code>PascalCase</code> 作为组件名的注册格式</p>
<p><code>&lt;PascalCase /&gt;</code> 在模板中更明显地表明了这是一个 Vue 组件，而不是原生 HTML 元素。同时也能够将 Vue 组件和自定义元素 (web components) 区分开来。</p>
<p>**为了方便，Vue 支持将模板中使用 kebab-case 的标签解析为使用 PascalCase 注册的组件。这意味着一个以 **<code>MyComponent</code> 为名注册的组件，在模板 (或由 Vue 渲染的 HTML 元素) 中可以通过 <code>&lt;MyComponent&gt;</code> 或 <code>&lt;my-component&gt;</code> 引用。</p>
<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p><strong>具名插槽</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父组件--&gt;</span><br><span class="line">&lt;HomeView&gt;</span><br><span class="line">  // 具名插槽简写</span><br><span class="line">  &lt;template #header&gt;点我&lt;/template&gt;</span><br><span class="line">  // 具名插槽全称</span><br><span class="line">  &lt;template v-slot:main&gt;content&lt;/template&gt;</span><br><span class="line">&lt;/HomeView&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  // 条件插槽,如果该div下有名为header的插槽时候，才会显示</span><br><span class="line">  &lt;div v-if=&quot;$slots.header&quot;&gt;</span><br><span class="line">    &lt;button&gt;&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button&gt;&lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p><strong>作用域插槽</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父组件--&gt;</span><br><span class="line">&lt;HomeView&gt;</span><br><span class="line">  // #header=&quot;&#123; massage &#125;作用为接受slot传送参数</span><br><span class="line">  &lt;template #header=&quot;&#123; massage &#125;&quot;&gt; &#123;&#123; massage &#125;&#125; &lt;/template&gt;</span><br><span class="line">&lt;/HomeView&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--子组件--&gt;</span><br><span class="line">  &lt;div id=&quot;HomeView&quot;&gt;</span><br><span class="line">    &lt;button&gt;</span><br><span class="line">// 传递参数massage</span><br><span class="line">      &lt;slot name=&quot;header&quot; massage=&quot;hello&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p><strong>作用域插槽实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父组件--&gt;</span><br><span class="line">&lt;HomeView&gt;</span><br><span class="line">  &lt;template #item=&quot;&#123; item &#125;&quot;&gt;</span><br><span class="line">    &#123;&#123; item.id &#125;&#125; : &#123;&#123; item.name &#125;&#125;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/HomeView&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--子组件--&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">    &lt;!--v-bind 来传递插槽的 props--&gt;</span><br><span class="line">    &lt;slot name=&quot;item&quot; :item&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p><strong>有些场景会需要在两个组件间来回切换，比如 Tab 界面</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;demo&quot;&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        v-for=&quot;(item, tab) in tabs&quot;</span><br><span class="line">        :key=&quot;tab&quot;</span><br><span class="line">        @click=&quot;currentTab = tab&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &#123;&#123; tab &#125;&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;component :is=&quot;tabs[currentTab]&quot;&gt;&lt;/component&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  import Home from &#x27;@/components/HomeView.vue&#x27;</span><br><span class="line">  import About from &#x27;@/components/AboutView.vue&#x27;</span><br><span class="line">  import &#123; ref, type Component &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  // 强制声明为动态键对象，并不是一个数组，而是一个对象（Object）。</span><br><span class="line">  // 它的类型会根据 Home 和 About 的具体类型自动推断。</span><br><span class="line">  const tabs: Record&lt;string, Component&gt; = &#123;</span><br><span class="line">    Home,</span><br><span class="line">    About,</span><br><span class="line">  &#125;</span><br><span class="line">  const currentTab = ref(&#x27;Home&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p><strong>传递 props：名字格式 camelCase</strong></p>
<p>**所有的 props 都遵循着****单向绑定**原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。</p>
<p>**另外，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，这意味着你****不应该**在子组件中去更改一个 prop。若你这么做了，Vue 会在控制台上向你抛出警告：<code>警告！prop 是只读的！</code></p>
<p><strong>你可以在子组件中定义一个局部变量，从 props 中获取数据的值，或者定义一个计算属性，依靠父组件传递的 props 而改变</strong></p>
<p>**在使用 **<code>&lt;script setup&gt;</code> 的单文件组件中，props 可以使用 <code>defineProps()</code> 宏来声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps([&#x27;foo&#x27;])</span><br><span class="line"></span><br><span class="line">console.log(props.foo)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>除了使用字符串数组来声明 props 外，还可以使用对象的形式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用 &lt;script setup&gt;</span><br><span class="line">defineProps(&#123;</span><br><span class="line">  title: String,</span><br><span class="line">  likes: Number,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>**如果你正在搭配 TypeScript 使用 **<code>&lt;script setup&gt;</code>，也可以使用类型标注来声明 props</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  defineProps&lt;&#123;</span><br><span class="line">    title?: string</span><br><span class="line">    likes?: number</span><br><span class="line">  &#125;&gt;()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>**当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但仍然****可以**更改对象或数组内部的值。这是因为 JavaScript 的对象和数组是按引用传递，对 Vue 来说，阻止这种更改需要付出的代价异常昂贵。</p>
<p><strong>这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。在最佳实践中，你应该尽可能避免这样的更改，除非父子组件在设计上本来就需要紧密耦合。</strong></p>
<h4 id="TS-解构语法"><a href="#TS-解构语法" class="headerlink" title="TS 解构语法"></a>TS 解构语法</h4><p><strong>1. 对象解构</strong></p>
<p><strong>基础解构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 定义对象</span><br><span class="line">const user = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  age: 30,</span><br><span class="line">  email: &#x27;alice@example.com&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解构并添加类型注解</span><br><span class="line">const &#123; name, age &#125;: &#123; name: string; age: number &#125; = user</span><br><span class="line"></span><br><span class="line">console.log(name) // &quot;Alice&quot;</span><br><span class="line">console.log(age) // 30</span><br></pre></td></tr></table></figure>

<p><strong>重命名 + 默认值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123; name: userName, role = &#x27;guest&#x27; &#125; = user</span><br><span class="line">// userName: string, role: string（默认值为 &quot;guest&quot;）</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 数组解构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 定义数组</span><br><span class="line">const numbers = [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">// 解构并添加类型注解</span><br><span class="line">const [first, second]: [number, number] = numbers</span><br><span class="line"></span><br><span class="line">console.log(first) // 1</span><br><span class="line">console.log(second) // 2</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>3. 函数参数解构</strong></p>
<p><strong>对象参数解构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解构参数并指定类型</span><br><span class="line">function printUser(&#123; name, age &#125;: User) &#123;</span><br><span class="line">  console.log(`$&#123;name&#125; is $&#123;age&#125; years old`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printUser(&#123; name: &#x27;Bob&#x27;, age: 25 &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h3><h4 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h4><p><strong>监听事件：父组件文件</strong></p>
<p><strong>方法 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;HomeView @increace-by=&quot;increaceBy&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// ts</span><br><span class="line">function increaceBy() &#123;</span><br><span class="line">  count.value += 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;HomeView @increace-by=&quot;(n) =&gt; (count += 1)&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>触发事件：子组件文件</strong></p>
<p><strong>配合方法 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">    &lt;button @click=&quot;emit(&#x27;increaceBy&#x27;, 1)&quot;&gt;</span><br><span class="line">      increace By 1</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">// ts</span><br><span class="line">const emit = defineEmits([&#x27;increaceBy&#x27;])</span><br></pre></td></tr></table></figure>

<p><strong>配合方法 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;$emit(&#x27;increaceBy&#x27;, 1)&quot;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h4 id="事件校验"><a href="#事件校验" class="headerlink" title="事件校验"></a>事件校验</h4><p><strong>存疑处…..</strong></p>
<h3 id="组件-v-model"><a href="#组件-v-model" class="headerlink" title="组件 v-model"></a>组件 v-model</h3><p><strong>原理实现 3.4 以前</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line">    &lt;HomeView</span><br><span class="line">// 单项传递值</span><br><span class="line">      :modelValue=&quot;value&quot;</span><br><span class="line">// 监听事件，并且更新传递值</span><br><span class="line">      @update:modelValue=&quot;($event) =&gt; (value = $event)&quot;</span><br><span class="line">    /&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;HomeView&quot;&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">// 绑定单向值</span><br><span class="line">      :value=&quot;props.modelValue&quot;</span><br><span class="line">// 触发事件</span><br><span class="line">      @input=&quot;</span><br><span class="line">        emit(</span><br><span class="line">          &#x27;update:modelValue&#x27;,</span><br><span class="line">          ($event.target as HTMLInputElement).value,</span><br><span class="line">        )</span><br><span class="line">      &quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">const props = defineProps([&#x27;modelValue&#x27;])</span><br><span class="line">const emit = defineEmits([&#x27;update:modelValue&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>简化实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">    &lt;HomeView v-model=&quot;value&quot; /&gt;&lt;template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div id=&quot;HomeView&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;updata&quot;&gt;&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">// ts</span><br><span class="line">const model = defineModel(&#123; default: 1 &#125;)</span><br><span class="line">function updata() &#123;</span><br><span class="line">  model.value++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="透传属性"><a href="#透传属性" class="headerlink" title="透传属性"></a>透传属性</h3><p>**“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或者 **<code>v-on</code> 事件监听器。最常见的例子就是 <code>class</code>、<code>style</code> 和 <code>id</code>。</p>
<h4 id="禁用透传属性"><a href="#禁用透传属性" class="headerlink" title="禁用透传属性"></a>禁用透传属性</h4><p>**如果你****不想要**一个组件自动地继承 attribute，你可以在组件选项中设置 <code>inheritAttrs: false</code>。从 3.3 开始你也可以直接在 <code>&lt;script setup&gt;</code> 中使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/sfc-script-setup.html#defineoptions"><code>defineOptions</code></a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">defineOptions(&#123;</span><br><span class="line">  inheritAttrs: false</span><br><span class="line">&#125;)</span><br><span class="line">// ...setup 逻辑</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>**这些透传进来的 attribute 可以在模板的表达式中直接用 **<code>$attrs</code> 访问到。</p>
<h4 id="多根节点继承问题"><a href="#多根节点继承问题" class="headerlink" title="多根节点继承问题"></a>多根节点继承问题</h4><p>**和单根节点组件有所不同，有着多个根节点的组件没有自动 attribute 透传行为。如果 **<code>$attrs</code> 没有被显式绑定，将会抛出一个运行时警告。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CustomLayout id=&quot;custom-layout&quot; @click=&quot;changeValue&quot; /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;...&lt;/header&gt;</span><br><span class="line">&lt;main&gt;...&lt;/main&gt;</span><br><span class="line">&lt;footer&gt;...&lt;/footer&gt;</span><br></pre></td></tr></table></figure>

<p>**如果 **<code>$attrs</code> 被显式绑定，则不会有警告：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;...&lt;/header&gt;</span><br><span class="line">&lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class="line">&lt;footer&gt;...&lt;/footer&gt;</span><br></pre></td></tr></table></figure>

<p>**如果需要，你可以在 **<code>&lt;script setup&gt;</code> 中使用 <code>useAttrs()</code> API 来访问一个组件的所有透传 attribute：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useAttrs &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const attrs = useAttrs()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><strong>父组件向自己的祖孙组件传递数据，若使用 props 则会逐级透传，但是中间组件根本不关心这些数据，</strong><code>provide</code> 和 <code>inject</code> 可以帮助我们解决这一问题。一个父组件相对于其所有的后代组件，会作为 <strong>依赖提供者</strong> 。任何后代的组件树，无论层级有多深，都可以<strong>注入</strong>由父组件提供给整条链路的依赖。</p>
<h2 id="闭包理解"><a href="#闭包理解" class="headerlink" title="闭包理解"></a>闭包理解</h2><p><strong>函数闭包：维护函数内变量，函数返回值是一个函数。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const add = (function () &#123;</span><br><span class="line">  let count = 0</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return (count += 1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h2 id="Pinia-全局状态管理"><a href="#Pinia-全局状态管理" class="headerlink" title="Pinia 全局状态管理"></a>Pinia 全局状态管理</h2><p>**Store (如 Pinia) 是一个保存状态和业务逻辑的实体，它并不与你的组件树绑定。换句话说， **<strong>它承载着全局状态</strong> 。它有点像一个永远存在的组件，每个组件都可以读取和写入它。它有 **三个概念** state、getter、action</p>
<p><strong>引入:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createPinia &#125; from &#x27;pinia&#x27;</span><br><span class="line">const pinia = createPinia()</span><br><span class="line">app.use(pinia)</span><br></pre></td></tr></table></figure>

<p><strong>定义 Store</strong></p>
<p><strong>在深入研究核心概念之前，我们得知道 Store 是用 <strong><code>defineStore()</code> 定义的，它的第一个参数要求是一个</strong>独一无二的</strong>名字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineStore &#125; from &#x27;pinia&#x27;</span><br><span class="line"></span><br><span class="line">// 你可以任意命名 `defineStore()` 的返回值，但最好使用 store 的名字，同时以 `use` 开头且以 `Store` 结尾。</span><br><span class="line">// (比如 `useUserStore`，`useCartStore`，`useProductStore`)</span><br><span class="line">// 第一个参数是你的应用中 Store 的唯一 ID。</span><br><span class="line">export const useAlertsStore = defineStore(&#x27;alerts&#x27;, &#123;</span><br><span class="line">  // 其他配置...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>**这个***<em>名字*</em> ，也被用作 <em>id</em> ，是必须传入的， Pinia 将用它来连接 store 和 devtools。为了养成习惯性的用法，将返回的函数命名为 *use…* 是一个符合组合式函数风格的约定。</p>
<p><code>defineStore()</code> 的第二个参数可接受两类值：Setup 函数或 Option 对象。</p>
<p><strong>选项式 store：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export const useCounterStore = defineStore(&#x27;counter&#x27;, &#123;</span><br><span class="line">  state: () =&gt; (&#123; count: 0, name: &#x27;Eduardo&#x27; &#125;),</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount: (state) =&gt; state.count * 2,</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>组合式 store</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export const useCounterStore = defineStore(&#x27;counter&#x27;, () =&gt; &#123;</span><br><span class="line">  const count = ref(0)</span><br><span class="line">  const doubleCount = computed(() =&gt; count.value * 2)</span><br><span class="line">  function increment() &#123;</span><br><span class="line">    count.value++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123; count, doubleCount, increment &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>**在 ***Setup Store* 中：</p>
<ul>
<li><code>ref()</code> 就是 <code>state</code> 属性</li>
<li><code>computed()</code> 就是 <code>getters</code></li>
<li><code>function()</code> 就是 <code>actions</code></li>
</ul>
<h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h2><ul>
<li><strong>查询字符串传参 Vs 路径传参</strong></li>
<li><strong>命名路由 Vs 别名路由</strong></li>
<li><strong>编程式导航</strong></li>
<li><strong>嵌套路由</strong></li>
<li><strong>路由重定向</strong></li>
<li><strong>路由守卫</strong></li>
<li><strong>命名视图</strong></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Vue3/" rel="tag"># Vue3</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/04/04/RESTfulAPI/" rel="prev" title="RESTful API介绍">
                  <i class="fa fa-angle-left"></i> RESTful API介绍
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/04/08/React/" rel="next" title="React使用手册">
                  React使用手册 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span >
      ||
    </span>
    <span class="author" itemprop="copyrightHolder">May</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">41k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:30</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数+时分秒...</span>

<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("01/01/2025 00:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "+hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
       
    }
setInterval("createtime()",250);
</script>
    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/May-531" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
