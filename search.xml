<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Css布局——Flex or Grid</title>
    <url>/2025/04/03/CssLayout/</url>
    <content><![CDATA[<h1 id="css-布局"><a href="#css-布局" class="headerlink" title="css 布局"></a>css 布局</h1><h2 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h2><p><strong>开启 flex 布局：</strong><code>display:flex</code></p>
<p><strong>属性：</strong></p>
<ul>
<li><strong>flex-grow：子元素大小等于子元素大小 + grow 的值的计算权重</strong></li>
<li><strong>flex-shrink：子元素大小等于子元素大小 - shrink 的值的计算权重</strong></li>
<li><strong>flex-basis：自定义每一个子元素大小</strong></li>
</ul>
<p><strong>复合属性：</strong></p>
<ul>
<li><strong>flex：</strong><code>flex: flex-grow flex-shrink flex-basis</code> （默认值：0 1 auto）</li>
<li><strong>：initial：默认值、auto：1 1 auto、none：0 0 auto</strong></li>
</ul>
<p><strong>垂直对齐：</strong><code>align-items</code></p>
<p><strong>设为</strong> <code>display:flex</code>时候，元素被强行拉为一行，等价于 <code>align-items:streatch</code>,此属性管的是元素在交叉轴（垂直轴）的对齐方式，是默认值，还可以设置:</p>
<ul>
<li><code>align-items:flex-start</code>：交叉轴起点对齐</li>
<li><code>align-items:flex-end</code>：交叉轴终点对齐</li>
<li><code>align-items:center</code>：交叉轴中点对齐</li>
<li><code>align-items:baseline</code>：文字基线对齐</li>
</ul>
<p><strong>水平对齐：</strong><code>justify-content</code></p>
<p><code>justify-content:flex-start</code>：默认值</p>
<ul>
<li><code>justify-content:flex-end</code></li>
<li><code>justify-content:center</code></li>
<li><code>justify-content:space-between</code>：首尾元素靠边</li>
<li><code>justify-content:space-around</code>：中间间距是两边间距两倍</li>
<li><code>justify-content:space-evenly</code>：均匀分布</li>
</ul>
<p><code>flex-wrap</code>：换行</p>
<ul>
<li><code>flex-wrap:nowrap</code>：默认值，不换行，子元素不会超过父元素大小</li>
<li><code>flex-wrap:wrap</code>：换行，每个元素都会编程原来的大小</li>
</ul>
<p><strong>使用 flex-wrap 换行之后，调整每行的对齐方式：</strong></p>
<ul>
<li><code>align-content:normal</code>：默认值，交叉轴方向</li>
<li><code>align-content:flex-start</code>：交叉轴开始对齐</li>
<li><code>align-content:flex-end</code>：交叉轴结束对齐</li>
<li><code>align-content:space-around</code>：交叉轴中间间距是两边间距两倍</li>
<li><code>align-content:space-between</code>：首尾元素靠边</li>
<li><code>align-content:space-evenly</code>：均匀分布</li>
</ul>
<p><code>order</code>属性：调整元素顺序</p>
<hr>
<h2 id="Grid-布局"><a href="#Grid-布局" class="headerlink" title="Grid 布局"></a>Grid 布局</h2><p><strong>开启 Grid 布局：</strong><code>display:grid</code></p>
<p><strong>指定列：</strong></p>
<ul>
<li><code>grid-template-columns:repeat(3, 50px);</code></li>
</ul>
<p><strong>等价于</strong></p>
<ul>
<li><code>grid-template-columns:50px 50px 50px;</code></li>
<li><code>grid-template-columns: 1fr 1fr 1fr;</code>：均分，fr 分数 x+x+x&#x3D;父元素宽度</li>
</ul>
<p>** 如果一行还有位置则填充 ,使用**<code>minmax</code>则会调整元素大小</p>
<ul>
<li><code>grid-template-columns: repeat(auto-fill,200px);</code></li>
<li><code>grid-template-columns: repeat(auto-fill,minmax(100px, 1fr));</code></li>
</ul>
<p><strong>指定行：</strong></p>
<ul>
<li><code>grid-template-rows: 20px 40px 60px;</code></li>
</ul>
<blockquote>
<p>template 优先级大于 auto 指定了的就用指定的 不指定就用 auto 设置的</p>
</blockquote>
<p><strong>行列间隙</strong></p>
<ul>
<li><code>grid-row-gap: 20px;</code> ：行空</li>
<li><code>grid-column-gap: 20px;</code>：列空</li>
<li><code>gap: 10px 50px;</code>：简写， (行，列)</li>
</ul>
<p><strong>指定区域：</strong></p>
<ul>
<li><strong>划线法：麻烦</strong></li>
<li><strong>区域法：给元素指定区域：</strong><code>grid-area:</code>，在父元素中指定区域放什么 <code>grid-template-areas</code>，其中可以使用 . 占位</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法学习</title>
    <url>/2025/02/07/KMP/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP串匹配算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL记录</title>
    <url>/2025/03/04/STL/</url>
    <content><![CDATA[<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>C++ STL（标准模板库）中最常用的容器包括：</p>
<ol>
<li><strong>vector</strong><ul>
<li>动态数组，支持随机访问，尾部插入和删除高效。</li>
<li>适用场景：需要频繁随机访问且尾部操作较多的情况。</li>
</ul>
</li>
<li><strong>list</strong><ul>
<li>双向链表，插入和删除高效，但不支持随机访问。</li>
<li>适用场景：频繁在任意位置插入或删除元素。</li>
</ul>
</li>
<li><strong>deque</strong><ul>
<li>双端队列，支持头部和尾部的高效插入与删除，允许随机访问。</li>
<li>适用场景：需要在两端频繁操作且偶尔随机访问。</li>
</ul>
</li>
<li><strong>stack栈</strong><ul>
<li>后进先出（LIFO）容器，基于deque或list实现。</li>
<li>适用场景：需要后进先出逻辑，如函数调用栈。</li>
</ul>
</li>
<li><strong>queue队列</strong><ul>
<li>先进先出（FIFO）容器，基于deque或list实现。</li>
<li>适用场景：需要先进先出逻辑，如任务调度。</li>
</ul>
</li>
<li><strong>priority_queue</strong><ul>
<li>优先队列，基于堆实现，元素按优先级排序。</li>
<li>适用场景：需要按优先级处理元素，如任务调度。</li>
</ul>
</li>
<li><strong>set</strong><ul>
<li>有序集合，元素唯一且自动排序，基于红黑树实现。</li>
<li>适用场景：需要有序且唯一的元素集合。</li>
</ul>
</li>
<li><strong>multiset</strong><ul>
<li>允许重复元素的有序集合，基于红黑树实现。</li>
<li>适用场景：需要有序但允许重复的元素集合。</li>
</ul>
</li>
<li><strong>map</strong><ul>
<li>有序键值对容器，键唯一且自动排序，基于红黑树实现。</li>
<li>适用场景：需要键值对且键唯一的有序集合。</li>
</ul>
</li>
<li><strong>multimap</strong><ul>
<li>允许重复键的有序键值对容器，基于红黑树实现。</li>
<li>适用场景：需要键值对但允许键重复的有序集合。</li>
</ul>
</li>
<li><strong>unordered_set</strong><ul>
<li>无序集合，元素唯一，基于哈希表实现。</li>
<li>适用场景：需要快速查找且不关心顺序的唯一元素集合。</li>
</ul>
</li>
<li><strong>unordered_multiset</strong><ul>
<li>允许重复元素的无序集合，基于哈希表实现。</li>
<li>适用场景：需要快速查找且允许重复的无序元素集合。</li>
</ul>
</li>
<li><strong>unordered_map</strong><ul>
<li>无序键值对容器，键唯一，基于哈希表实现。</li>
<li>适用场景：需要快速查找且不关心顺序的键值对集合。</li>
</ul>
</li>
<li><strong>unordered_multimap</strong><ul>
<li>允许重复键的无序键值对容器，基于哈希表实现。</li>
<li>适用场景：需要快速查找且允许键重复的无序键值对集合。</li>
</ul>
</li>
</ol>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>初始化方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec1; <span class="comment">// 空的 vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec2</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">//  5 个初始值为 0</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;<span class="comment">//包含 5 个元素,初始值为 10</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec4 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">//初始化列表</span></span><br></pre></td></tr></table></figure>

<p><code>.reserve()</code>与 <code>.resize()方法</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">10</span>); <span class="comment">// 仅仅预留空间大小，若用[]访问会访问野空间，使用at访问则会抛出异常</span></span><br><span class="line">std::cout&lt;&lt;vec.<span class="built_in">capacity</span>()&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;vec.<span class="built_in">at</span>(<span class="number">0</span>)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">10</span>); <span class="comment">// 此时分配的空间是实打实的空间，全部初始化为0</span></span><br><span class="line">std::cout&lt;&lt;vec.<span class="built_in">at</span>(<span class="number">0</span>)&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>

<p>添加元素&#x2F;删除元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">10</span>);<span class="comment">// 在尾部添加元素</span></span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="number">40</span>);<span class="comment">// 使用 emplace_back 直接构造元素</span></span><br><span class="line">vec.<span class="built_in">pop_back</span>();<span class="comment">// 删除最后一个元素</span></span><br><span class="line">vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>);<span class="comment">// 删除指定位置的元素（删除第 2 个元素）</span></span><br></pre></td></tr></table></figure>

<p>访问方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Element at index 2: &quot;</span> &lt;&lt; vec[<span class="number">2</span>] &lt;&lt; std::endl;<span class="comment">// 使用下标访问元素  </span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Element at index 3: &quot;</span> &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">3</span>) &lt;&lt; std::endl;<span class="comment">// 使用 at() 访问元素（会检查边界）  </span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; vec.<span class="built_in">front</span>() &lt;&lt; std::endl;<span class="comment">// 访问第一个</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Last element: &quot;</span> &lt;&lt; vec.<span class="built_in">back</span>() &lt;&lt; std::endl;<span class="comment">//最后一个元素</span></span><br></pre></td></tr></table></figure>

<p>遍历方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;<span class="comment">// 使用下标遍历  </span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Using range-based for loop: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : vec) &#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;  <span class="comment">// 使用范围 for 循环遍历</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;<span class="comment">// 使用迭代器遍历</span></span><br></pre></td></tr></table></figure>

<p>排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());    <span class="comment">// 对 vector 进行升序排序</span></span><br></pre></td></tr></table></figure>

<p>交换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">vec<span class="number">1.</span><span class="built_in">swap</span>(vec2);</span><br></pre></td></tr></table></figure>

<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>初始化与vector保持一致。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">初始化与vector保持一致。</span><br></pre></td></tr></table></figure>

<p>添加元素<br><code>.push_back()</code>在尾部添加元素，<code>.push_front()</code>在头部添加元素。</p>
<p>访问元素</p>
<p><code>.front()</code>访问头 <code>.back()</code>访问尾。</p>
<p>删除</p>
<p><code>.pop_front()</code>删除头部元素 <code>.pop_back()</code>删除尾部元素。</p>
<p>成员函数</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>push_back</code></th>
<th><code>emplace_back</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>临时对象</strong></td>
<td>需要创建临时对象</td>
<td>不需要创建临时对象</td>
</tr>
<tr>
<td><strong>拷贝&#x2F;移动操作</strong></td>
<td>可能涉及拷贝或移动操作</td>
<td>无拷贝或移动操作</td>
</tr>
<tr>
<td><strong>多参数构造</strong></td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>较低（涉及额外开销）</td>
<td>较高（直接构造）</td>
</tr>
<tr>
<td><strong>代码简洁性</strong></td>
<td>需要显式构造对象</td>
<td>直接传递构造参数</td>
</tr>
</tbody></table>
<p>因此，在大多数情况下，推荐使用 <code>emplace_back</code>，尤其是在需要高效构造对象或传递多个构造参数的场景中。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello CMAKE</title>
    <url>/2025/02/27/cmake/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>默认标签</category>
      </categories>
      <tags>
        <tag>默认标签</tag>
      </tags>
  </entry>
  <entry>
    <title>c++学习路线</title>
    <url>/2025/02/27/cpp_stage/</url>
    <content><![CDATA[<h3 id="一、基础阶段（1-3个月）"><a href="#一、基础阶段（1-3个月）" class="headerlink" title="一、基础阶段（1-3个月）"></a><strong>一、基础阶段（1-3个月）</strong></h3><h4 id="目标：掌握C-核心语法与编程思想，写出健壮的面向过程代码"><a href="#目标：掌握C-核心语法与编程思想，写出健壮的面向过程代码" class="headerlink" title="目标：掌握C++核心语法与编程思想，写出健壮的面向过程代码"></a><strong>目标</strong>：掌握C++核心语法与编程思想，写出健壮的面向过程代码</h4><ol>
<li><strong>语法基础</strong><ul>
<li><strong>数据类型、运算符、控制流（if&#x2F;for&#x2F;while）</strong></li>
<li><strong>函数：参数传递（值&#x2F;指针&#x2F;引用）、函数重载</strong></li>
<li><strong>数组、字符串（C风格字符串与</strong> <code>std::string</code>）</li>
<li><strong>结构体、枚举、联合体</strong></li>
<li><strong>关键练习</strong>：实现计算器、学生成绩管理系统</li>
</ul>
</li>
<li><strong>内存管理</strong><ul>
<li><strong>堆与栈的区别、</strong><code>new</code>&#x2F;<code>delete</code>操作</li>
<li><strong>指针与引用的本质区别</strong></li>
<li><strong>动态数组（</strong><code>new int[n]</code>）与内存泄漏检测工具（Valgrind）</li>
<li><strong>关键练习</strong>：实现自定义动态数组类（模拟 <code>std::vector</code>雏形）</li>
</ul>
</li>
<li><strong>面向对象（OOP）</strong><ul>
<li><strong>类与对象：封装、构造&#x2F;析构函数</strong></li>
<li><strong>继承与多态：虚函数、抽象类</strong></li>
<li><strong>运算符重载（</strong><code>+</code>, <code>&lt;&lt;</code>等）</li>
<li><strong>关键练习</strong>：设计图形类层次（Shape→Circle&#x2F;Rectangle）</li>
</ul>
</li>
</ol>
<hr>
<h3 id="二、进阶阶段（3-6个月）"><a href="#二、进阶阶段（3-6个月）" class="headerlink" title="二、进阶阶段（3-6个月）"></a><strong>二、进阶阶段（3-6个月）</strong></h3><h4 id="目标：深入理解C-标准库与现代特性，掌握工程级代码规范"><a href="#目标：深入理解C-标准库与现代特性，掌握工程级代码规范" class="headerlink" title="目标：深入理解C++标准库与现代特性，掌握工程级代码规范"></a><strong>目标</strong>：深入理解C++标准库与现代特性，掌握工程级代码规范</h4><ol>
<li><strong>标准库（STL）</strong><ul>
<li><strong>容器：</strong><code>vector</code>&#x2F;<code>list</code>&#x2F;<code>map</code>&#x2F;<code>unordered_map</code></li>
<li><strong>算法：</strong><code>sort</code>&#x2F;<code>find</code>&#x2F;<code>transform</code></li>
<li><strong>迭代器与仿函数（函数对象）</strong></li>
<li><strong>关键练习</strong>：统计文本词频（<code>map</code>+文件操作）</li>
</ul>
</li>
<li><strong>模板与泛型编程</strong><ul>
<li><strong>函数模板与类模板</strong></li>
<li><strong>模板特化与偏特化</strong></li>
<li><strong>关键练习</strong>：实现泛型排序算法（支持自定义比较）</li>
</ul>
</li>
<li><strong>现代C++（C++11&#x2F;14&#x2F;17）</strong><ul>
<li><strong>智能指针：</strong><code>unique_ptr</code>&#x2F;<code>shared_ptr</code></li>
<li><strong>右值引用与移动语义</strong></li>
<li><strong>Lambda表达式、范围for循环</strong></li>
<li><strong>关键练习</strong>：重构旧代码，用智能指针替代裸指针</li>
</ul>
</li>
<li><strong>异常处理与RAII</strong><ul>
<li><code>try</code>&#x2F;<code>catch</code>机制</li>
<li><strong>资源获取即初始化（RAII）模式</strong></li>
<li><strong>关键练习</strong>：实现文件自动关闭类（利用析构函数）</li>
</ul>
</li>
</ol>
<hr>
<h3 id="三、高阶阶段（6-12个月）"><a href="#三、高阶阶段（6-12个月）" class="headerlink" title="三、高阶阶段（6-12个月）"></a><strong>三、高阶阶段（6-12个月）</strong></h3><h4 id="目标：掌握系统级编程与性能优化，深入特定领域"><a href="#目标：掌握系统级编程与性能优化，深入特定领域" class="headerlink" title="目标：掌握系统级编程与性能优化，深入特定领域"></a><strong>目标</strong>：掌握系统级编程与性能优化，深入特定领域</h4><ol>
<li><strong>多线程与并发</strong><ul>
<li><code>std::thread</code>、<code>std::async</code></li>
<li><strong>互斥锁（</strong><code>mutex</code>）、条件变量（<code>condition_variable</code>）</li>
<li><strong>原子操作（</strong><code>atomic</code>）与无锁编程</li>
<li><strong>关键练习</strong>：实现生产者-消费者模型</li>
</ul>
</li>
<li><strong>系统编程</strong><ul>
<li><strong>文件系统操作（</strong><code>&lt;filesystem&gt;</code>）</li>
<li><strong>网络编程（Socket、Boost.Asio库）</strong></li>
<li><strong>内存对齐与缓存优化</strong></li>
<li><strong>关键练习</strong>：实现简易HTTP服务器</li>
</ul>
</li>
<li><strong>模板元编程与编译期计算</strong><ul>
<li><strong>类型萃取（Type Traits）</strong></li>
<li><strong>SFINAE与</strong> <code>constexpr</code></li>
<li><strong>关键练习</strong>：实现编译期斐波那契数列计算</li>
</ul>
</li>
<li><strong>领域深入（选择1-2个方向）</strong><ul>
<li><strong>游戏开发</strong>：Unreal Engine C++、OpenGL&#x2F;DirectX</li>
<li><strong>高频交易</strong>：低延迟优化、锁无关数据结构</li>
<li><strong>嵌入式</strong>：RTOS、硬件寄存器操作</li>
<li><strong>开源贡献</strong>：参与LLVM&#x2F;Clang、Chromium等项目</li>
</ul>
</li>
</ol>
<hr>
<h3 id="四、工程化实践"><a href="#四、工程化实践" class="headerlink" title="四、工程化实践"></a><strong>四、工程化实践</strong></h3><ol>
<li><strong>构建工具</strong><ul>
<li><strong>CMake编写跨平台构建脚本</strong></li>
<li><strong>包管理：vcpkg&#x2F;conan</strong></li>
</ul>
</li>
<li><strong>调试与性能分析</strong><ul>
<li><strong>GDB&#x2F;LLDB调试核心转储（Core Dump）</strong></li>
<li><strong>性能剖析工具：perf、gprof、VTune</strong></li>
</ul>
</li>
<li><strong>代码质量</strong><ul>
<li><strong>静态分析：Clang-Tidy、Cppcheck</strong></li>
<li><strong>单元测试：Google Test框架</strong></li>
<li><strong>代码规范：Google C++ Style Guide</strong></li>
</ul>
</li>
</ol>
<hr>
<h3 id="五、学习资源推荐"><a href="#五、学习资源推荐" class="headerlink" title="五、学习资源推荐"></a><strong>五、学习资源推荐</strong></h3><h4 id="书籍（按难度排序）："><a href="#书籍（按难度排序）：" class="headerlink" title="书籍（按难度排序）："></a><strong>书籍</strong>（按难度排序）：</h4><ol>
<li><strong>入门</strong>：《C++ Primer》《Accelerated C++》</li>
<li><strong>进阶</strong>：《Effective C++》《Effective Modern C++》</li>
<li><strong>高阶</strong>：《C++ Concurrency in Action》《Template Metaprogramming》</li>
</ol>
<h4 id="在线课程："><a href="#在线课程：" class="headerlink" title="在线课程："></a><strong>在线课程</strong>：</h4><ul>
<li><strong>Coursera：北大《程序设计与算法》</strong></li>
<li><strong>Udemy：Beginning C++ Programming - From Beginner to Beyond</strong></li>
</ul>
<h4 id="开源项目："><a href="#开源项目：" class="headerlink" title="开源项目："></a><strong>开源项目</strong>：</h4><ul>
<li>入门级： <a href="https://github.com/qinguoyi/TinyWebServer">TinyWebServer</a>（学习网络编程）</li>
<li>进阶级： <a href="https://github.com/fmtlib/fmt">fmtlib</a>（学习现代C++库设计）</li>
</ul>
<hr>
<h3 id="六、项目实战建议"><a href="#六、项目实战建议" class="headerlink" title="六、项目实战建议"></a><strong>六、项目实战建议</strong></h3><table>
<thead>
<tr>
<th><strong>阶段</strong></th>
<th><strong>项目示例</strong></th>
<th><strong>技术要点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>初级</strong></td>
<td><strong>命令行日记本</strong></td>
<td><strong>文件操作、OOP设计</strong></td>
</tr>
<tr>
<td><strong>中级</strong></td>
<td><strong>多线程日志库</strong></td>
<td><strong>线程安全、RAII、性能优化</strong></td>
</tr>
<tr>
<td><strong>高级</strong></td>
<td><strong>简易数据库引擎（LSM-Tree实现）</strong></td>
<td><strong>磁盘IO、内存管理、并发控制</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="七、求职与职业发展"><a href="#七、求职与职业发展" class="headerlink" title="七、求职与职业发展"></a><strong>七、求职与职业发展</strong></h3><ol>
<li><strong>简历重点</strong>：<ul>
<li><strong>突出高性能&#x2F;高并发项目经验</strong></li>
<li><strong>展示对内存管理与多线程的深刻理解</strong></li>
</ul>
</li>
<li><strong>面试高频考点</strong>：<ul>
<li><strong>虚函数表（vtable）实现原理</strong></li>
<li><code>std::vector</code>扩容机制</li>
<li><strong>智能指针循环引用问题</strong></li>
<li><strong>多线程死锁场景分析</strong></li>
</ul>
</li>
<li><strong>职业路径</strong>：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初级C++开发 → 系统架构师/游戏引擎工程师 → 技术专家（特定领域）</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="避坑指南"><a href="#避坑指南" class="headerlink" title="避坑指南"></a><strong>避坑指南</strong></h3><ol>
<li><strong>避免过早优化</strong>：先保证正确性，再考虑性能（“Make it work, make it right, make it fast”）</li>
<li><strong>慎用裸指针</strong>：优先使用智能指针和RAII管理资源</li>
<li><strong>关注C++标准演进</strong>：C++20&#x2F;23的Module、Coroutine等新特性</li>
</ol>
]]></content>
      <categories>
        <category>学习路线</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello C++</title>
    <url>/2025/02/07/hello-cpp/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>C/C++环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql聚合查询</title>
    <url>/2025/03/02/groupby/</url>
    <content><![CDATA[<h3 id="1-基础聚合函数"><a href="#1-基础聚合函数" class="headerlink" title="1. 基础聚合函数"></a><strong>1. 基础聚合函数</strong></h3><h4 id="1-COUNT：统计行数"><a href="#1-COUNT：统计行数" class="headerlink" title="(1) COUNT：统计行数"></a>(1) <strong><code>COUNT</code></strong>：统计行数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 统计所有员工数量</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> total_employees <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 统计有部门的员工数量（排除 NULL）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(department_id) <span class="keyword">AS</span> employees_with_dept <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h4 id="2-SUM：求和"><a href="#2-SUM：求和" class="headerlink" title="(2) SUM：求和"></a>(2) <strong><code>SUM</code></strong>：求和</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 计算所有订单的总金额</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount <span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure>

<h4 id="3-AVG：求平均值"><a href="#3-AVG：求平均值" class="headerlink" title="(3) AVG：求平均值"></a>(3) <strong><code>AVG</code></strong>：求平均值</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 计算员工的平均工资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h4 id="4-MAX-MIN：最大值-最小值"><a href="#4-MAX-MIN：最大值-最小值" class="headerlink" title="(4) MAX&#x2F;MIN：最大值&#x2F;最小值"></a>(4) <strong><code>MAX</code>&#x2F;<code>MIN</code></strong>：最大值&#x2F;最小值</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 找最高和最低工资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> max_salary, <span class="built_in">MIN</span>(salary) <span class="keyword">AS</span> min_salary <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-GROUP-BY：分组聚合"><a href="#2-GROUP-BY：分组聚合" class="headerlink" title="2. GROUP BY：分组聚合"></a><strong>2. <code>GROUP BY</code>：分组聚合</strong></h3><h4 id="示例表结构"><a href="#示例表结构" class="headerlink" title="示例表结构"></a>示例表结构</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> sales (</span><br><span class="line">    product_id <span class="type">INT</span>,</span><br><span class="line">    category <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    sale_date <span class="type">DATE</span>,</span><br><span class="line">    amount <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> sales <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Electronics&#x27;</span>, <span class="string">&#x27;2023-01-01&#x27;</span>, <span class="number">1000</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Electronics&#x27;</span>, <span class="string">&#x27;2023-01-02&#x27;</span>, <span class="number">1500</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Clothing&#x27;</span>, <span class="string">&#x27;2023-01-01&#x27;</span>, <span class="number">500</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Clothing&#x27;</span>, <span class="string">&#x27;2023-01-02&#x27;</span>, <span class="number">800</span>);</span><br></pre></td></tr></table></figure>

<h4 id="查询示例"><a href="#查询示例" class="headerlink" title="查询示例"></a>查询示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按商品类别统计总销售额</span></span><br><span class="line"><span class="keyword">SELECT</span> category, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category;</span><br></pre></td></tr></table></figure>

<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>category</th>
<th>total_sales</th>
</tr>
</thead>
<tbody><tr>
<td>Electronics</td>
<td>2500.00</td>
</tr>
<tr>
<td>Clothing</td>
<td>1300.00</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-HAVING：过滤分组结果"><a href="#3-HAVING：过滤分组结果" class="headerlink" title="3. HAVING：过滤分组结果"></a><strong>3. <code>HAVING</code>：过滤分组结果</strong></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 筛选总销售额超过 2000 的类别</span></span><br><span class="line"><span class="keyword">SELECT</span> category, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category</span><br><span class="line"><span class="keyword">HAVING</span> total_sales <span class="operator">&gt;</span> <span class="number">2000</span>;</span><br></pre></td></tr></table></figure>

<h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>category</th>
<th>total_sales</th>
</tr>
</thead>
<tbody><tr>
<td>Electronics</td>
<td>2500.00</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-多字段分组"><a href="#4-多字段分组" class="headerlink" title="4. 多字段分组"></a><strong>4. 多字段分组</strong></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按商品 ID 和日期统计销售额</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, sale_date, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> daily_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id, sale_date;</span><br></pre></td></tr></table></figure>

<h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>product_id</th>
<th>sale_date</th>
<th>daily_sales</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2023-01-01</td>
<td>1000.00</td>
</tr>
<tr>
<td>1</td>
<td>2023-01-02</td>
<td>1500.00</td>
</tr>
<tr>
<td>2</td>
<td>2023-01-01</td>
<td>500.00</td>
</tr>
<tr>
<td>2</td>
<td>2023-01-02</td>
<td>800.00</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-WITH-ROLLUP：生成小计和总计"><a href="#5-WITH-ROLLUP：生成小计和总计" class="headerlink" title="5. WITH ROLLUP：生成小计和总计"></a><strong>5. <code>WITH ROLLUP</code>：生成小计和总计</strong></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按类别和商品 ID 统计销售额，并生成小计和总计</span></span><br><span class="line"><span class="keyword">SELECT</span> category, product_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category, product_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure>

<h4 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>category</th>
<th>product_id</th>
<th>total_sales</th>
</tr>
</thead>
<tbody><tr>
<td>Clothing</td>
<td>2</td>
<td>1300.00</td>
</tr>
<tr>
<td>Clothing</td>
<td>NULL</td>
<td>1300.00</td>
</tr>
<tr>
<td>Electronics</td>
<td>1</td>
<td>2500.00</td>
</tr>
<tr>
<td>Electronics</td>
<td>NULL</td>
<td>2500.00</td>
</tr>
<tr>
<td>NULL</td>
<td>NULL</td>
<td>3800.00</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-聚合函数结合条件"><a href="#6-聚合函数结合条件" class="headerlink" title="6. 聚合函数结合条件"></a><strong>6. 聚合函数结合条件</strong></h3><h4 id="1-CASE-WHEN-实现条件聚合"><a href="#1-CASE-WHEN-实现条件聚合" class="headerlink" title="(1) CASE WHEN 实现条件聚合"></a>(1) <strong><code>CASE WHEN</code> 实现条件聚合</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 统计 2023-01-01 和 2023-01-02 的销售额</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sale_date <span class="operator">=</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">THEN</span> amount <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> sales_day1,</span><br><span class="line">    <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sale_date <span class="operator">=</span> <span class="string">&#x27;2023-01-02&#x27;</span> <span class="keyword">THEN</span> amount <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> sales_day2</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure>

<h4 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>sales_day1</th>
<th>sales_day2</th>
</tr>
</thead>
<tbody><tr>
<td>1500.00</td>
<td>2300.00</td>
</tr>
</tbody></table>
<h4 id="2-IF-函数简化条件"><a href="#2-IF-函数简化条件" class="headerlink" title="(2) IF 函数简化条件"></a>(2) <strong><code>IF</code> 函数简化条件</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 统计高价商品（金额 &gt; 1000）的销售额</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(IF(amount <span class="operator">&gt;</span> <span class="number">1000</span>, amount, <span class="number">0</span>)) <span class="keyword">AS</span> high_value_sales <span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-聚合函数与去重"><a href="#7-聚合函数与去重" class="headerlink" title="7. 聚合函数与去重"></a><strong>7. 聚合函数与去重</strong></h3><h4 id="使用-DISTINCT"><a href="#使用-DISTINCT" class="headerlink" title="使用 DISTINCT"></a>使用 <code>DISTINCT</code></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 统计不同商品的销售次数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> product_id) <span class="keyword">AS</span> unique_products <span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong><code>GROUP BY</code> 与非聚合字段</strong><br>SELECT 中的非聚合字段必须出现在 <code>GROUP BY</code> 中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 正确写法</span></span><br><span class="line"><span class="keyword">SELECT</span> category, product_id, <span class="built_in">SUM</span>(amount)</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category, product_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 错误写法（product_id 未在 GROUP BY 中）</span></span><br><span class="line"><span class="keyword">SELECT</span> category, product_id, <span class="built_in">SUM</span>(amount)</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category;</span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>HAVING</code> 与 <code>WHERE</code> 的区别</strong></p>
<ul>
<li><code>WHERE</code> 在聚合前过滤行。</li>
<li><code>HAVING</code> 在聚合后过滤分组。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>聚合查询的核心用途：</p>
<ul>
<li>统计汇总数据（如总数、总和、平均值）。</li>
<li>按维度（如时间、类别）分组分析。</li>
<li>过滤聚合结果（如筛选销售额超过阈值的分组）。</li>
</ul>
<p>通过灵活组合聚合函数、<code>GROUP BY</code> 和 <code>HAVING</code>，可以高效实现复杂的数据分析需求。</p>
<h1 id="力扣已刷相关题"><a href="#力扣已刷相关题" class="headerlink" title="力扣已刷相关题"></a>力扣已刷相关题</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>表: <code>Person</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| id          | int     |</span><br><span class="line">| email       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">id 是该表的主键（具有唯一值的列）。</span><br><span class="line">此表的每一行都包含一封电子邮件。电子邮件不包含大写字母。</span><br></pre></td></tr></table></figure>

<p>编写解决方案来报告所有重复的电子邮件。 请注意，可以保证电子邮件字段不为 NULL。</p>
<p>以 **任意顺序 **返回结果表。</p>
<p>结果格式如下例。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 
Person 表:
+----+---------+
| id | email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
<strong>输出:</strong> 
+---------+
| Email   |
+---------+
| a@b.com |
+---------+
<strong>解释:</strong> a@b.com 出现了两次。</pre>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> email <span class="keyword">as</span> Email</span><br><span class="line"><span class="keyword">from</span> Person</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> email</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(email) <span class="operator">&gt;</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="题目：511-游戏玩法分析I"><a href="#题目：511-游戏玩法分析I" class="headerlink" title="题目：511.游戏玩法分析I"></a>题目：511.游戏玩法分析I</h2><p>活动表 <code>Activity</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| player_id    | int     |</span><br><span class="line">| device_id    | int     |</span><br><span class="line">| event_date   | date    |</span><br><span class="line">| games_played | int     |</span><br><span class="line">+--------------+---------+</span><br><span class="line">在 SQL 中，表的主键是 (player_id, event_date)。</span><br><span class="line">这张表展示了一些游戏玩家在游戏平台上的行为活动。</span><br><span class="line">每行数据记录了一名玩家在退出平台之前，当天使用同一台设备登录平台后打开的游戏的数目（可能是 0 个）。</span><br></pre></td></tr></table></figure>

<p>查询每位玩家 <strong>第一次登录平台的日期</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> player_id, <span class="built_in">min</span>(event_date) <span class="keyword">as</span> first_login</span><br><span class="line"><span class="keyword">from</span> Activity</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> player_id</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo</title>
    <url>/2025/02/06/hello-world/</url>
    <content><![CDATA[<p>记录Hexo搭建博客使用基本命令与操作。</p>
<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><h3 id="Clean"><a href="#Clean" class="headerlink" title="Clean"></a>Clean</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>

<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>
<h3 id="Generate"><a href="#Generate" class="headerlink" title="Generate"></a>Generate</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p>生成静态文件。</p>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>启动服务器。 默认情况下，访问网址为： <a href="http://localhost:4000/">http://localhost:4000/</a></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-p, –port</td>
<td>重设端口</td>
</tr>
<tr>
<td>-s, –static</td>
<td>只使用静态文件</td>
</tr>
<tr>
<td>-l, –log</td>
<td>启用日志Override logger format.</td>
</tr>
</tbody></table>
<h3 id="Newhexo-new-page-–path-about-me-“About-me”"><a href="#Newhexo-new-page-–path-about-me-“About-me”" class="headerlink" title="Newhexo new page –path about&#x2F;me “About me”"></a>Newhexo new page –path about&#x2F;me “About me”</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page --path about/me <span class="string">&quot;About me&quot;</span></span><br></pre></td></tr></table></figure>

<p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter中title 为 <code>&quot;About me&quot;</code></p>
<h3 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<p>推送至github远程仓库。</p>
<h2 id="Front-Matter"><a href="#Front-Matter" class="headerlink" title="Front Matter"></a>Front Matter</h2><table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>标题</td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
</tr>
<tr>
<td>description</td>
<td>文章描述</td>
</tr>
<tr>
<td>tags</td>
<td>标签</td>
</tr>
<tr>
<td>categories</td>
<td>分类</td>
</tr>
<tr>
<td>updated</td>
<td>更新日期</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式如下</span><br><span class="line">title: Hello Hexo</span><br><span class="line">description: 记录Hexo搭建博客使用操作。</span><br><span class="line">categories:</span><br><span class="line">  - Hello</span><br><span class="line">tags:</span><br><span class="line">  - Hexo入门</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>Hexo入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello deepseek</title>
    <url>/2025/02/07/init_deepseek/</url>
    <content><![CDATA[<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="1-下载ollama"><a href="#1-下载ollama" class="headerlink" title="1. 下载ollama"></a>1. 下载ollama</h3><p>官网地址：<a href="https://ollama.com/">Ollama</a></p>
<blockquote>
<p>Ollama：是一个开源框架，用户可以使用Ollama在计算机本地创建语言模型。简单的说就是使用它可以在你自己的电脑上创建类似ChatGpt或者kimi那样的AI大模型应用。并且还可以自己训、微调你的大模型，让他为你干活。</p>
</blockquote>
<h3 id="2-修改model下载路径"><a href="#2-修改model下载路径" class="headerlink" title="2. 修改model下载路径"></a>2. 修改model下载路径</h3><p>新建系统变量：OLLAMA_MODELS，并选定合适位置。</p>
<h3 id="3-下载合适model"><a href="#3-下载合适model" class="headerlink" title="3. 下载合适model"></a>3. 下载合适model</h3><p>在该页面<a href="https://ollama.com/library/deepseek-r1">deepseek-r1</a>选择合适model，复制命令，如 <code>ollama run deepseek-r1:14b </code>，打开cmd开始下载。</p>
<h3 id="4-选择合适图形化界面"><a href="#4-选择合适图形化界面" class="headerlink" title="4. 选择合适图形化界面"></a>4. 选择合适图形化界面</h3><p>这里选择<a href="https://chatboxai.app/zh">Chatbox</a>，进入app后选择ollama api，随后按选项自定义即可。</p>
<h3 id="5-Cherry-Studio-API配置"><a href="#5-Cherry-Studio-API配置" class="headerlink" title="5. Cherry Studio API配置"></a>5. Cherry Studio API配置</h3><p>API配置更加适合本地部署不占用内存，在官网申请免费的api即可。</p>
]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>deepseek-r1本地部署</tag>
        <tag>AI大模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello markdown</title>
    <url>/2025/02/07/markdown/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>markdown入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql常用操作</title>
    <url>/2025/02/27/mysql/</url>
    <content><![CDATA[<h3 id="一、数据库操作"><a href="#一、数据库操作" class="headerlink" title="一、数据库操作"></a><strong>一、数据库操作</strong></h3><h4 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1. 创建数据库"></a>1. 创建数据库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS `test_db` DEFAULT CHARACTER SET utf8mb4;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>：创建名为 <code>test_db</code> 的数据库，字符集为 <code>utf8mb4</code>（支持中文和表情符号）。</p>
<h4 id="2-切换数据库"><a href="#2-切换数据库" class="headerlink" title="2. 切换数据库"></a>2. 切换数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE `test_db`;</span><br></pre></td></tr></table></figure>

<h4 id="3-删除数据库"><a href="#3-删除数据库" class="headerlink" title="3. 删除数据库"></a>3. 删除数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS `test_db`;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二、表操作"><a href="#二、表操作" class="headerlink" title="二、表操作"></a><strong>二、表操作</strong></h3><h4 id="1-创建表（含字段约束）"><a href="#1-创建表（含字段约束）" class="headerlink" title="1. 创建表（含字段约束）"></a>1. 创建表（含字段约束）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `users` (</span><br><span class="line">  `id` INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  `name` VARCHAR(50) NOT NULL,</span><br><span class="line">  `email` VARCHAR(100) UNIQUE,</span><br><span class="line">  `age` INT DEFAULT 18,</span><br><span class="line">  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>字段说明</strong>：</p>
<ul>
<li><code>PRIMARY KEY</code>：主键约束</li>
<li><code>AUTO_INCREMENT</code>：自增</li>
<li><code>UNIQUE</code>：唯一约束</li>
<li><code>DEFAULT</code>：默认值</li>
</ul>
<h4 id="2-修改表结构"><a href="#2-修改表结构" class="headerlink" title="2. 修改表结构"></a>2. 修改表结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 添加新列</span><br><span class="line">ALTER TABLE `users` ADD COLUMN `gender` ENUM(&#x27;male&#x27;, &#x27;female&#x27;) AFTER `age`;</span><br><span class="line"></span><br><span class="line">-- 修改列类型</span><br><span class="line">ALTER TABLE `users` MODIFY COLUMN `name` VARCHAR(100);</span><br><span class="line"></span><br><span class="line">-- 删除列</span><br><span class="line">ALTER TABLE `users` DROP COLUMN `gender`;</span><br></pre></td></tr></table></figure>

<h4 id="3-删除表"><a href="#3-删除表" class="headerlink" title="3. 删除表"></a>3. 删除表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `users`;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="三、数据操作（CRUD）"><a href="#三、数据操作（CRUD）" class="headerlink" title="三、数据操作（CRUD）"></a><strong>三、数据操作（CRUD）</strong></h3><h4 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 插入单条数据</span><br><span class="line">INSERT INTO `users` (`name`, `email`, `age`) </span><br><span class="line">VALUES (&#x27;Alice&#x27;, &#x27;alice@example.com&#x27;, 25);</span><br><span class="line"></span><br><span class="line">-- 插入多条数据</span><br><span class="line">INSERT INTO `users` (`name`, `email`) </span><br><span class="line">VALUES (&#x27;Bob&#x27;, &#x27;bob@test.com&#x27;), (&#x27;Charlie&#x27;, &#x27;charlie@test.com&#x27;);</span><br></pre></td></tr></table></figure>

<h4 id="2-查询数据"><a href="#2-查询数据" class="headerlink" title="2. 查询数据"></a>2. 查询数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询所有字段</span><br><span class="line">SELECT * FROM `users`;</span><br><span class="line"></span><br><span class="line">-- 条件查询（WHERE）</span><br><span class="line">SELECT `name`, `age` FROM `users` WHERE `age` &gt; 20;</span><br><span class="line"></span><br><span class="line">-- 排序（ORDER BY）</span><br><span class="line">SELECT * FROM `users` ORDER BY `created_at` DESC;</span><br><span class="line"></span><br><span class="line">-- 分页（LIMIT）</span><br><span class="line">SELECT * FROM `users` LIMIT 10 OFFSET 0; -- 第1页，每页10条</span><br></pre></td></tr></table></figure>

<h4 id="3-更新数据"><a href="#3-更新数据" class="headerlink" title="3. 更新数据"></a>3. 更新数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE `users` </span><br><span class="line">SET `age` = 30, `email` = &#x27;alice_new@example.com&#x27; </span><br><span class="line">WHERE `id` = 1;</span><br></pre></td></tr></table></figure>

<h4 id="4-删除数据"><a href="#4-删除数据" class="headerlink" title="4. 删除数据"></a>4. 删除数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM `users` WHERE `id` = 3;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="四、复杂查询"><a href="#四、复杂查询" class="headerlink" title="四、复杂查询"></a><strong>四、复杂查询</strong></h3><h4 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1. 聚合函数"></a>1. 聚合函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 统计总数、平均值</span><br><span class="line">SELECT COUNT(*) AS total_users, AVG(age) AS avg_age FROM `users`;</span><br><span class="line"></span><br><span class="line">-- 分组统计（GROUP BY）</span><br><span class="line">SELECT `gender`, COUNT(*) AS count FROM `users` GROUP BY `gender`;</span><br></pre></td></tr></table></figure>

<h4 id="2-连接查询（JOIN）"><a href="#2-连接查询（JOIN）" class="headerlink" title="2. 连接查询（JOIN）"></a>2. 连接查询（JOIN）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建订单表</span><br><span class="line">CREATE TABLE `orders` (</span><br><span class="line">  `order_id` INT PRIMARY KEY,</span><br><span class="line">  `user_id` INT,</span><br><span class="line">  `amount` DECIMAL(10,2),</span><br><span class="line">  FOREIGN KEY (`user_id`) REFERENCES `users`(`id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 内连接（INNER JOIN）</span><br><span class="line">SELECT u.`name`, o.`order_id`, o.`amount`</span><br><span class="line">FROM `users` u</span><br><span class="line">INNER JOIN `orders` o ON u.`id` = o.`user_id`;</span><br></pre></td></tr></table></figure>

<h4 id="3-子查询"><a href="#3-子查询" class="headerlink" title="3. 子查询"></a>3. 子查询</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT `name` </span><br><span class="line">FROM `users` </span><br><span class="line">WHERE `id` IN (SELECT `user_id` FROM `orders` WHERE `amount` &gt; 100);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="五、高级功能"><a href="#五、高级功能" class="headerlink" title="五、高级功能"></a><strong>五、高级功能</strong></h3><h4 id="1-索引优化"><a href="#1-索引优化" class="headerlink" title="1. 索引优化"></a>1. 索引优化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建索引</span><br><span class="line">CREATE INDEX `idx_email` ON `users` (`email`);</span><br><span class="line"></span><br><span class="line">-- 查看索引</span><br><span class="line">SHOW INDEX FROM `users`;</span><br></pre></td></tr></table></figure>

<h4 id="2-事务处理"><a href="#2-事务处理" class="headerlink" title="2. 事务处理"></a>2. 事务处理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE `account` SET balance = balance - 100 WHERE user_id = 1;</span><br><span class="line">UPDATE `account` SET balance = balance + 100 WHERE user_id = 2;</span><br><span class="line">COMMIT; -- 提交事务</span><br><span class="line">-- ROLLBACK; -- 回滚事务</span><br></pre></td></tr></table></figure>

<h4 id="3-用户权限管理"><a href="#3-用户权限管理" class="headerlink" title="3. 用户权限管理"></a>3. 用户权限管理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建用户并授权</span><br><span class="line">CREATE USER &#x27;dev_user&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password123&#x27;;</span><br><span class="line">GRANT SELECT, INSERT, UPDATE ON `test_db`.* TO &#x27;dev_user&#x27;@&#x27;%&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="六、实用命令"><a href="#六、实用命令" class="headerlink" title="六、实用命令"></a><strong>六、实用命令</strong></h3><h4 id="1-导入-导出数据"><a href="#1-导入-导出数据" class="headerlink" title="1. 导入&#x2F;导出数据"></a>1. 导入&#x2F;导出数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 导出整个数据库（命令行）</span><br><span class="line">mysqldump -u root -p test_db &gt; backup.sql</span><br><span class="line"></span><br><span class="line"># 导入数据</span><br><span class="line">mysql -u root -p test_db &lt; backup.sql</span><br></pre></td></tr></table></figure>

<h4 id="2-查看表结构"><a href="#2-查看表结构" class="headerlink" title="2. 查看表结构"></a>2. 查看表结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC `users`;</span><br></pre></td></tr></table></figure>

<h4 id="3-查看建表语句"><a href="#3-查看建表语句" class="headerlink" title="3. 查看建表语句"></a>3. 查看建表语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE `users`;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="高频场景示例"><a href="#高频场景示例" class="headerlink" title="高频场景示例"></a><strong>高频场景示例</strong></h3><h4 id="场景1：分页查询用户列表（每页5条）"><a href="#场景1：分页查询用户列表（每页5条）" class="headerlink" title="场景1：分页查询用户列表（每页5条）"></a>场景1：分页查询用户列表（每页5条）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `users` </span><br><span class="line">ORDER BY `id` </span><br><span class="line">LIMIT 5 OFFSET 0; -- 第1页</span><br></pre></td></tr></table></figure>

<h4 id="场景2：模糊查询（查找名字包含-“DB”-的用户）"><a href="#场景2：模糊查询（查找名字包含-“DB”-的用户）" class="headerlink" title="场景2：模糊查询（查找名字包含 “DB” 的用户）"></a>场景2：模糊查询（查找名字包含 “DB” 的用户）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `users` </span><br><span class="line">WHERE `name` LIKE &#x27;%DB%&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="场景3：批量更新状态"><a href="#场景3：批量更新状态" class="headerlink" title="场景3：批量更新状态"></a>场景3：批量更新状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE `products` </span><br><span class="line">SET `status` = &#x27;offline&#x27; </span><br><span class="line">WHERE `stock` = 0;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 连接查询</title>
    <url>/2025/03/02/mysql_join_connect/</url>
    <content><![CDATA[<h3 id="1-内连接（INNER-JOIN）"><a href="#1-内连接（INNER-JOIN）" class="headerlink" title="1. 内连接（INNER JOIN）"></a>1. <strong>内连接（INNER JOIN）</strong></h3><ul>
<li><strong>作用</strong>：返回两个表中匹配的行。</li>
<li><strong>语法</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列</span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>列 <span class="operator">=</span> 表<span class="number">2.</span>列;</span><br></pre></td></tr></table></figure></li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, orders.amount</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-左连接（LEFT-JOIN）"><a href="#2-左连接（LEFT-JOIN）" class="headerlink" title="2. 左连接（LEFT JOIN）"></a>2. <strong>左连接（LEFT JOIN）</strong></h3><ul>
<li><strong>作用</strong>：返回左表所有行，右表无匹配时填充 <code>NULL</code>。</li>
<li><strong>语法</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列</span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>列 <span class="operator">=</span> 表<span class="number">2.</span>列;</span><br></pre></td></tr></table></figure></li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, orders.amount</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-右连接（RIGHT-JOIN）"><a href="#3-右连接（RIGHT-JOIN）" class="headerlink" title="3. 右连接（RIGHT JOIN）"></a>3. <strong>右连接（RIGHT JOIN）</strong></h3><ul>
<li><strong>作用</strong>：返回右表所有行，左表无匹配时填充 <code>NULL</code>。</li>
<li><strong>语法</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列</span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>列 <span class="operator">=</span> 表<span class="number">2.</span>列;</span><br></pre></td></tr></table></figure></li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, orders.amount</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-全外连接（FULL-OUTER-JOIN）"><a href="#4-全外连接（FULL-OUTER-JOIN）" class="headerlink" title="4. 全外连接（FULL OUTER JOIN）"></a>4. <strong>全外连接（FULL OUTER JOIN）</strong></h3><ul>
<li><strong>作用</strong>：返回两表所有行，无匹配时填充 <code>NULL</code>（MySQL需用 <code>UNION</code>模拟）。</li>
<li><strong>语法</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> 列 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br></pre></td></tr></table></figure></li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, orders.amount <span class="keyword">FROM</span> users <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> users.name, orders.amount <span class="keyword">FROM</span> users <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="5-交叉连接（CROSS-JOIN）"><a href="#5-交叉连接（CROSS-JOIN）" class="headerlink" title="5. 交叉连接（CROSS JOIN）"></a>5. <strong>交叉连接（CROSS JOIN）</strong></h3><ul>
<li><strong>作用</strong>：返回笛卡尔积（所有可能的行组合）。</li>
<li><strong>语法</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> 表<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, products.price</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> products;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="6-自连接（SELF-JOIN）"><a href="#6-自连接（SELF-JOIN）" class="headerlink" title="6. 自连接（SELF JOIN）"></a>6. <strong>自连接（SELF JOIN）</strong></h3><ul>
<li><strong>作用</strong>：同一表内连接，常用于层级数据（如员工与经理）。</li>
<li><strong>语法</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.列, b.列</span><br><span class="line"><span class="keyword">FROM</span> 表 a</span><br><span class="line"><span class="keyword">JOIN</span> 表 b <span class="keyword">ON</span> a.列 <span class="operator">=</span> b.列;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h1><p>以下是每种连接查询的具体实例，包含表结构、示例数据和对应的 SQL 语句：</p>
<hr>
<h3 id="1-内连接（INNER-JOIN）-1"><a href="#1-内连接（INNER-JOIN）-1" class="headerlink" title="1. 内连接（INNER JOIN）"></a><strong>1. 内连接（INNER JOIN）</strong></h3><h4 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> employees (</span><br><span class="line">    employee_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    department_id <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> departments (</span><br><span class="line">    department_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    department_name <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> employees <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="number">101</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="number">102</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="keyword">NULL</span>);  <span class="comment">-- 无部门</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> departments <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">101</span>, <span class="string">&#x27;HR&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;IT&#x27;</span>),</span><br><span class="line">(<span class="number">103</span>, <span class="string">&#x27;Finance&#x27;</span>);  <span class="comment">-- 无员工</span></span><br></pre></td></tr></table></figure>

<h4 id="查询示例"><a href="#查询示例" class="headerlink" title="查询示例"></a>查询示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取有部门的员工及其部门名称</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments </span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>

<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>name</th>
<th>department_name</th>
</tr>
</thead>
<tbody><tr>
<td>Alice</td>
<td>HR</td>
</tr>
<tr>
<td>Bob</td>
<td>IT</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：仅返回 <code>employees</code> 和 <code>departments</code> 中 <code>department_id</code> 匹配的行，无部门的员工（Charlie）和无员工的部门（Finance）被过滤。</p>
<hr>
<h3 id="2-左连接（LEFT-JOIN）-1"><a href="#2-左连接（LEFT-JOIN）-1" class="headerlink" title="2. 左连接（LEFT JOIN）"></a><strong>2. 左连接（LEFT JOIN）</strong></h3><h4 id="查询示例-1"><a href="#查询示例-1" class="headerlink" title="查询示例"></a>查询示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取所有员工（包括无部门的员工）</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments </span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>

<h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>name</th>
<th>department_name</th>
</tr>
</thead>
<tbody><tr>
<td>Alice</td>
<td>HR</td>
</tr>
<tr>
<td>Bob</td>
<td>IT</td>
</tr>
<tr>
<td>Charlie</td>
<td>NULL</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：保留左表（<code>employees</code>）的所有行，无部门的员工 <code>department_name</code> 显示为 <code>NULL</code>。</p>
<hr>
<h3 id="3-右连接（RIGHT-JOIN）-1"><a href="#3-右连接（RIGHT-JOIN）-1" class="headerlink" title="3. 右连接（RIGHT JOIN）"></a><strong>3. 右连接（RIGHT JOIN）</strong></h3><h4 id="查询示例-2"><a href="#查询示例-2" class="headerlink" title="查询示例"></a>查询示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取所有部门（包括无员工的部门）</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments </span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>

<h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>name</th>
<th>department_name</th>
</tr>
</thead>
<tbody><tr>
<td>Alice</td>
<td>HR</td>
</tr>
<tr>
<td>Bob</td>
<td>IT</td>
</tr>
<tr>
<td>NULL</td>
<td>Finance</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：保留右表（<code>departments</code>）的所有行，无员工的部门对应的 <code>name</code> 显示为 <code>NULL</code>。</p>
<hr>
<h3 id="4-全外连接（FULL-OUTER-JOIN）-1"><a href="#4-全外连接（FULL-OUTER-JOIN）-1" class="headerlink" title="4. 全外连接（FULL OUTER JOIN）"></a><strong>4. 全外连接（FULL OUTER JOIN）</strong></h3><h4 id="查询示例-3"><a href="#查询示例-3" class="headerlink" title="查询示例"></a>查询示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用 UNION 模拟全外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>

<h4 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>name</th>
<th>department_name</th>
</tr>
</thead>
<tbody><tr>
<td>Alice</td>
<td>HR</td>
</tr>
<tr>
<td>Bob</td>
<td>IT</td>
</tr>
<tr>
<td>Charlie</td>
<td>NULL</td>
</tr>
<tr>
<td>NULL</td>
<td>Finance</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：结合左连接和右连接的结果，返回所有员工和部门（包含未匹配的行）。</p>
<hr>
<h3 id="5-交叉连接（CROSS-JOIN）-1"><a href="#5-交叉连接（CROSS-JOIN）-1" class="headerlink" title="5. 交叉连接（CROSS JOIN）"></a><strong>5. 交叉连接（CROSS JOIN）</strong></h3><h4 id="表结构-1"><a href="#表结构-1" class="headerlink" title="表结构"></a>表结构</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> colors (color <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br><span class="line"><span class="keyword">CREATE TABLE</span> sizes (size <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> colors <span class="keyword">VALUES</span> (<span class="string">&#x27;Red&#x27;</span>), (<span class="string">&#x27;Blue&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> sizes <span class="keyword">VALUES</span> (<span class="string">&#x27;S&#x27;</span>), (<span class="string">&#x27;M&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="查询示例-4"><a href="#查询示例-4" class="headerlink" title="查询示例"></a>查询示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 生成颜色和尺寸的所有组合</span></span><br><span class="line"><span class="keyword">SELECT</span> colors.color, sizes.size</span><br><span class="line"><span class="keyword">FROM</span> colors</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> sizes;</span><br></pre></td></tr></table></figure>

<h4 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>color</th>
<th>size</th>
</tr>
</thead>
<tbody><tr>
<td>Red</td>
<td>S</td>
</tr>
<tr>
<td>Red</td>
<td>M</td>
</tr>
<tr>
<td>Blue</td>
<td>S</td>
</tr>
<tr>
<td>Blue</td>
<td>M</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：返回两表的笛卡尔积（所有可能组合）。</p>
<hr>
<h3 id="6-自连接（SELF-JOIN）-1"><a href="#6-自连接（SELF-JOIN）-1" class="headerlink" title="6. 自连接（SELF JOIN）"></a><strong>6. 自连接（SELF JOIN）</strong></h3><h4 id="表结构-2"><a href="#表结构-2" class="headerlink" title="表结构"></a>表结构</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> staff (</span><br><span class="line">    employee_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    manager_id <span class="type">INT</span>  <span class="comment">-- 指向同一表的 employee_id</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> staff <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="keyword">NULL</span>),   <span class="comment">-- 顶级领导</span></span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="number">1</span>),        <span class="comment">-- Alice 的下属</span></span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="number">1</span>);    <span class="comment">-- Alice 的下属</span></span><br></pre></td></tr></table></figure>

<h4 id="查询示例-5"><a href="#查询示例-5" class="headerlink" title="查询示例"></a>查询示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 显示员工及其上级经理</span></span><br><span class="line"><span class="keyword">SELECT</span> a.name <span class="keyword">AS</span> employee, b.name <span class="keyword">AS</span> manager</span><br><span class="line"><span class="keyword">FROM</span> staff a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> staff b </span><br><span class="line"><span class="keyword">ON</span> a.manager_id <span class="operator">=</span> b.employee_id;</span><br></pre></td></tr></table></figure>

<h4 id="结果-5"><a href="#结果-5" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>employee</th>
<th>manager</th>
</tr>
</thead>
<tbody><tr>
<td>Alice</td>
<td>NULL</td>
</tr>
<tr>
<td>Bob</td>
<td>Alice</td>
</tr>
<tr>
<td>Charlie</td>
<td>Alice</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：通过自连接将员工与其上级关联，左表为员工，右表为对应的上级。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过具体示例可以直观理解不同连接的行为：</p>
<ul>
<li><strong>INNER JOIN</strong>：仅保留匹配的行。</li>
<li><strong>LEFT&#x2F;RIGHT JOIN</strong>：保留主表所有行，从表无匹配时填充 <code>NULL</code>。</li>
<li><strong>FULL OUTER JOIN</strong>：结合左右连接的并集。</li>
<li><strong>CROSS JOIN</strong>：生成笛卡尔积。</li>
<li><strong>SELF JOIN</strong>：同一表内关联不同行。</li>
</ul>
<p>力扣已刷相关题：</p>
<p>表: <code>Person</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| FirstName   | varchar |</span><br><span class="line">| LastName    | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">personId 是该表的主键（具有唯一值的列）。</span><br><span class="line">该表包含一些人的 ID 和他们的姓和名的信息。</span><br></pre></td></tr></table></figure>

<p>表: <code>Address</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| AddressId   | int     |</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| City        | varchar |</span><br><span class="line">| State       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">addressId 是该表的主键（具有唯一值的列）。</span><br><span class="line">该表的每一行都包含一个 ID = PersonId 的人的城市和州的信息。</span><br></pre></td></tr></table></figure>

<p>编写解决方案，报告 <code>Person</code> 表中每个人的姓、名、城市和州。如果 <code>personId</code> 的地址不在 <code>Address</code> 表中，则报告为 <code>null</code> 。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 
Person表:
+----------+----------+-----------+
| personId | lastName | firstName |
+----------+----------+-----------+
| 1        | Wang     | Allen     |
| 2        | Alice    | Bob       |
+----------+----------+-----------+
Address表:
+-----------+----------+---------------+------------+
| addressId | personId | city          | state      |
+-----------+----------+---------------+------------+
| 1         | 2        | New York City | New York   |
| 2         | 3        | Leetcode      | California |
+-----------+----------+---------------+------------+
<strong>输出:</strong> 
+-----------+----------+---------------+----------+
| firstName | lastName | city          | state    |
+-----------+----------+---------------+----------+
| Allen     | Wang     | Null          | Null     |
| Bob       | Alice    | New York City | New York |
+-----------+----------+---------------+----------+
<strong>解释:</strong> 
地址表中没有 personId = 1 的地址，所以它们的城市和州返回 null。
addressId = 1 包含了 personId = 2 的地址信息。</pre>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 题解</span><br><span class="line"><span class="keyword">select</span> firstName, lastName, city, state </span><br><span class="line"><span class="keyword">from</span> Person <span class="keyword">left</span> <span class="keyword">join</span> Address </span><br><span class="line"><span class="keyword">on</span> Person.PersonID <span class="operator">=</span> Address.PersonID</span><br></pre></td></tr></table></figure>

<p>表：<code>Employee</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| empId       | int     |</span><br><span class="line">| name        | varchar |</span><br><span class="line">| supervisor  | int     |</span><br><span class="line">| salary      | int     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">empId 是该表中具有唯一值的列。</span><br><span class="line">该表的每一行都表示员工的姓名和 id，以及他们的工资和经理的 id。</span><br></pre></td></tr></table></figure>

<p>表：<code>Bonus</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+------+</span><br><span class="line">| Column Name | Type |</span><br><span class="line">+-------------+------+</span><br><span class="line">| empId       | int  |</span><br><span class="line">| bonus       | int  |</span><br><span class="line">+-------------+------+</span><br><span class="line">empId 是该表具有唯一值的列。</span><br><span class="line">empId 是 Employee 表中 empId 的外键(reference 列)。</span><br><span class="line">该表的每一行都包含一个员工的 id 和他们各自的奖金。</span><br></pre></td></tr></table></figure>

<p>编写解决方案，报告每个奖金 <strong>少于</strong> <code>1000</code> 的员工的姓名和奖金数额。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。</p>
<p>结果格式如下所示。</p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>
Employee table:
+-------+--------+------------+--------+
| empId | name   | supervisor | salary |
+-------+--------+------------+--------+
| 3     | Brad   | null       | 4000   |
| 1     | John   | 3          | 1000   |
| 2     | Dan    | 3          | 2000   |
| 4     | Thomas | 3          | 4000   |
+-------+--------+------------+--------+
Bonus table:
+-------+-------+
| empId | bonus |
+-------+-------+
| 2     | 500   |
| 4     | 2000  |
+-------+-------+
<b>输出：</b>
+------+-------+
| name | bonus |
+------+-------+
| Brad | null  |
| John | null  |
| Dan  | 500   |
+------+-------+</pre>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 题解</span><br><span class="line"><span class="keyword">select</span> name, bonus </span><br><span class="line"><span class="keyword">from</span> Employee <span class="keyword">left</span> <span class="keyword">join</span> Bonus </span><br><span class="line"><span class="keyword">on</span> Employee.empId <span class="operator">=</span> Bonus.empId </span><br><span class="line"><span class="keyword">where</span> bonus <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">or</span> bonus <span class="operator">&lt;</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中复杂用法小计</title>
    <url>/2025/03/03/noteC-1/</url>
    <content><![CDATA[<h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><p>例：二维数组分配。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> **array;</span><br><span class="line"><span class="comment">// 假定数组第一维长度为 m， 第二维长度为 n</span></span><br><span class="line"><span class="comment">// 动态分配空间</span></span><br><span class="line">array = <span class="keyword">new</span> <span class="type">int</span> *[m];</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++ )</span><br><span class="line">&#123;</span><br><span class="line">    array[i] = <span class="keyword">new</span> <span class="type">int</span> [n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] array[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> [] array;</span><br></pre></td></tr></table></figure>

<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><ul>
<li>shared_ptr：共享一个对象</li>
<li>unique_ptr：独占一个对象</li>
<li>weak_ptr：</li>
</ul>
<blockquote>
<p>shared_ptr常用 <code>std::make_shared &lt;&gt; ()</code>来创建</p>
</blockquote>
<p>shared_ptr使用引用计数来判断是否销毁指针空间，但也存在内存泄漏问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;B&gt; pointer;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; pointer;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    <span class="keyword">auto</span> b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;pointer = b;</span><br><span class="line">    b-&gt;pointer = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 <code>a,b</code>，这使得 <code>a,b</code> 的引用计数均变为了 2，而离开作用域时，<code>a,b</code> 智能指针被析构，却只能造成这块区域的引用计数减一，这样就导致了 <code>a,b</code> 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露。</p>
<p>解决这个问题的办法就是使用弱引用指针 <code>std::weak_ptr</code>，<code>std::weak_ptr</code>是一种弱引用（相比较而言 <code>std::shared_ptr</code> 就是一种强引用）。弱引用不会引起引用计数增加。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日一题——IF函数</title>
    <url>/2025/03/04/mysqlnote-1/</url>
    <content><![CDATA[<h1 id="610-判断三角形"><a href="#610-判断三角形" class="headerlink" title="610.判断三角形"></a>610.判断三角形</h1><p>表: <code>Triangle</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+------+</span><br><span class="line">| Column Name | Type |</span><br><span class="line">+-------------+------+</span><br><span class="line">| x           | int  |</span><br><span class="line">| y           | int  |</span><br><span class="line">| z           | int  |</span><br><span class="line">+-------------+------+</span><br><span class="line">在 SQL 中，(x, y, z)是该表的主键列。</span><br><span class="line">该表的每一行包含三个线段的长度。</span><br></pre></td></tr></table></figure>

<p>对每三个线段报告它们是否可以形成一个三角形。</p>
<p>以 **任意顺序 **返回结果表。</p>
<p>查询结果格式如下所示。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 
Triangle 表:
+----+----+----+
| x  | y  | z  |
+----+----+----+
| 13 | 15 | 30 |
| 10 | 20 | 15 |
+----+----+----+
<strong>输出:</strong> 
+----+----+----+----------+
| x  | y  | z  | triangle |
+----+----+----+----------+
| 13 | 15 | 30 | No       |
| 10 | 20 | 15 | Yes      |
+----+----+----+----------+</pre>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> x,y,z,<span class="keyword">if</span>(x+y&gt;z and x+z&gt;y and y+z&gt;x, <span class="string">&quot;Yes&quot;</span>, <span class="string">&quot;No&quot;</span>) as triangle</span><br><span class="line">from triangle</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣Mysql每日一题(interval)</title>
    <url>/2025/03/03/mysqlnote/</url>
    <content><![CDATA[<p>在 MySQL 中，<code>INTERVAL</code> 不是一种字段类型，而是一个<strong>用于日期和时间计算的运算符</strong>。它通常与日期函数（如 <code>DATE_ADD()</code>, <code>DATE_SUB()</code>）或直接日期表达式结合使用，用来表示时间间隔。以下是 <code>INTERVAL</code> 的常见用法和示例：</p>
<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a><strong>1. 基本语法</strong></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DATE_ADD(base_date, <span class="type">INTERVAL</span> <span class="keyword">value</span> unit)</span><br><span class="line">DATE_SUB(base_date, <span class="type">INTERVAL</span> <span class="keyword">value</span> unit)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>base_date</code></strong>：基准日期（如 <code>CURDATE()</code>, <code>NOW()</code> 或字段名）。</li>
<li><strong><code>value</code></strong>：数值（正负均可）。</li>
<li><strong><code>unit</code></strong>：时间单位（如 <code>DAY</code>, <code>MONTH</code>, <code>YEAR</code>, <code>HOUR</code>, <code>MINUTE</code> 等）。</li>
</ul>
<hr>
<h3 id="2-常见使用场景"><a href="#2-常见使用场景" class="headerlink" title="2. 常见使用场景"></a><strong>2. 常见使用场景</strong></h3><h4 id="场景-1：日期加减"><a href="#场景-1：日期加减" class="headerlink" title="场景 1：日期加减"></a><strong>场景 1：日期加减</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 当前时间加 7 天</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(NOW(), <span class="type">INTERVAL</span> <span class="number">7</span> <span class="keyword">DAY</span>) <span class="keyword">AS</span> future_date;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当前时间减 3 小时</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">HOUR</span>) <span class="keyword">AS</span> past_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 直接使用 `+ INTERVAL` 简化语法</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW() <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span> <span class="keyword">AS</span> next_month;</span><br></pre></td></tr></table></figure>

<h4 id="场景-2：计算字段的过期时间"><a href="#场景-2：计算字段的过期时间" class="headerlink" title="场景 2：计算字段的过期时间"></a><strong>场景 2：计算字段的过期时间</strong></h4><p>假设有一个 <code>orders</code> 表，需要计算订单到期时间（创建时间 + 30 天）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    order_id, </span><br><span class="line">    created_at, </span><br><span class="line">    created_at <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">30</span> <span class="keyword">DAY</span> <span class="keyword">AS</span> expire_date</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure>

<h4 id="场景-3：过滤时间范围"><a href="#场景-3：过滤时间范围" class="headerlink" title="场景 3：过滤时间范围"></a><strong>场景 3：过滤时间范围</strong></h4><p>查询最近 7 天内的订单：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> order_date <span class="operator">&gt;=</span> NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">7</span> <span class="keyword">DAY</span>;</span><br></pre></td></tr></table></figure>

<h4 id="场景-4：生成时间序列"><a href="#场景-4：生成时间序列" class="headerlink" title="场景 4：生成时间序列"></a><strong>场景 4：生成时间序列</strong></h4><p>生成过去 12 个月的月份序列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    DATE_FORMAT(NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> n <span class="keyword">MONTH</span>, <span class="string">&#x27;%Y-%m&#x27;</span>) <span class="keyword">AS</span> <span class="keyword">month</span></span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">0</span> <span class="keyword">AS</span> n <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">2</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">3</span> <span class="keyword">UNION</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">4</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">5</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">6</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">7</span> <span class="keyword">UNION</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">8</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">9</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">10</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">11</span></span><br><span class="line">) <span class="keyword">AS</span> numbers;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-支持的-INTERVAL-单位"><a href="#3-支持的-INTERVAL-单位" class="headerlink" title="3. 支持的 INTERVAL 单位"></a><strong>3. 支持的 <code>INTERVAL</code> 单位</strong></h3><p>MySQL 支持以下时间单位：</p>
<table>
<thead>
<tr>
<th>单位</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>MICROSECOND</code></td>
<td>微秒</td>
</tr>
<tr>
<td><code>SECOND</code></td>
<td>秒</td>
</tr>
<tr>
<td><code>MINUTE</code></td>
<td>分钟</td>
</tr>
<tr>
<td><code>HOUR</code></td>
<td>小时</td>
</tr>
<tr>
<td><code>DAY</code></td>
<td>天</td>
</tr>
<tr>
<td><code>WEEK</code></td>
<td>周</td>
</tr>
<tr>
<td><code>MONTH</code></td>
<td>月</td>
</tr>
<tr>
<td><code>QUARTER</code></td>
<td>季度（3 个月）</td>
</tr>
<tr>
<td><code>YEAR</code></td>
<td>年</td>
</tr>
<tr>
<td><code>SECOND_MICROSECOND</code></td>
<td>秒和微秒（如 <code>&#39;30.5&#39; SECOND_MICROSECOND</code>）</td>
</tr>
<tr>
<td><code>MINUTE_MICROSECOND</code></td>
<td>分钟、秒和微秒</td>
</tr>
<tr>
<td>…（其他复合单位）</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-存储时间间隔的字段设计"><a href="#4-存储时间间隔的字段设计" class="headerlink" title="4. 存储时间间隔的字段设计"></a><strong>4. 存储时间间隔的字段设计</strong></h3><p>如果需要在表中存储时间间隔（如“有效期 30 天”），通常用以下两种方式：</p>
<h4 id="方式-1：分开存储数值和单位"><a href="#方式-1：分开存储数值和单位" class="headerlink" title="方式 1：分开存储数值和单位"></a><strong>方式 1：分开存储数值和单位</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> subscriptions (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    duration <span class="type">INT</span>,       <span class="comment">-- 时间长度（如 30）</span></span><br><span class="line">    duration_unit <span class="type">VARCHAR</span>(<span class="number">10</span>)  <span class="comment">-- 单位（如 &#x27;DAY&#x27;）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算过期时间</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    DATE_ADD(start_date, <span class="type">INTERVAL</span> duration duration_unit) <span class="keyword">AS</span> expire_date</span><br><span class="line"><span class="keyword">FROM</span> subscriptions;</span><br></pre></td></tr></table></figure>

<h4 id="方式-2：统一存储为秒数"><a href="#方式-2：统一存储为秒数" class="headerlink" title="方式 2：统一存储为秒数"></a><strong>方式 2：统一存储为秒数</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> tasks (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    timeout_seconds <span class="type">INT</span>  <span class="comment">-- 存储总秒数（如 3600 表示 1 小时）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 转换为时间间隔</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    DATE_ADD(start_time, <span class="type">INTERVAL</span> timeout_seconds <span class="keyword">SECOND</span>) <span class="keyword">AS</span> end_time</span><br><span class="line"><span class="keyword">FROM</span> tasks;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-复杂示例：自动分区按时间间隔"><a href="#5-复杂示例：自动分区按时间间隔" class="headerlink" title="5. 复杂示例：自动分区按时间间隔"></a><strong>5. 复杂示例：自动分区按时间间隔</strong></h3><p>使用 <code>INTERVAL</code> 创建按月的自动分区表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> logs (</span><br><span class="line">    log_date DATETIME,</span><br><span class="line">    content TEXT</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> COLUMNS(log_date) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p202301 <span class="keyword">VALUES</span> LESS THAN (<span class="string">&#x27;2023-02-01&#x27;</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p202302 <span class="keyword">VALUES</span> LESS THAN (<span class="string">&#x27;2023-03-01&#x27;</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p202303 <span class="keyword">VALUES</span> LESS THAN (<span class="string">&#x27;2023-04-01&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a><strong>6. 注意事项</strong></h3><ol>
<li><p><strong>时区问题</strong><br>使用 <code>INTERVAL</code> 计算时，确保基准日期和结果的时区一致（可通过 <code>CONVERT_TZ()</code> 转换）。</p>
</li>
<li><p><strong>闰年和月末</strong><br>加减月份时，MySQL 会自动处理月末：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 2023-01-31 + 1 MONTH → 2023-02-28</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="string">&#x27;2023-01-31&#x27;</span>, <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span>); </span><br></pre></td></tr></table></figure></li>
<li><p><strong>索引失效</strong><br>避免在 <code>WHERE</code> 条件中对字段使用函数（如 <code>DATE_ADD(column, INTERVAL ...)</code>），可能导致索引失效。建议改写为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 优化前（索引可能失效）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> logs <span class="keyword">WHERE</span> DATE_ADD(log_date, <span class="type">INTERVAL</span> <span class="number">7</span> <span class="keyword">DAY</span>) <span class="operator">&gt;</span> NOW();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化后（直接比较字段）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> logs <span class="keyword">WHERE</span> log_date <span class="operator">&gt;</span> NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">7</span> <span class="keyword">DAY</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p><code>INTERVAL</code> 是 MySQL 中处理日期和时间计算的核心工具，适用于：</p>
<ul>
<li>动态计算未来或过去的日期。</li>
<li>生成时间序列或过滤时间范围。</li>
<li>设计需要存储时间间隔的业务逻辑。</li>
</ul>
<p>结合 <code>DATE_ADD()</code>、<code>DATE_SUB()</code> 和直接日期表达式，可以高效实现复杂的时间操作。</p>
<h1 id="题目：197-上升的温度"><a href="#题目：197-上升的温度" class="headerlink" title="题目：197.上升的温度"></a>题目：197.上升的温度</h1><p>表： <code>Weather</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| recordDate    | date    |</span><br><span class="line">| temperature   | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是该表具有唯一值的列。</span><br><span class="line">没有具有相同 recordDate 的不同行。</span><br><span class="line">该表包含特定日期的温度信息</span><br></pre></td></tr></table></figure>

<p>编写解决方案，找出与之前（昨天的）日期相比温度更高的所有日期的 <code>id</code> 。</p>
<p>返回结果 <strong>无顺序要求</strong> 。</p>
<p>结果格式如下例子所示。</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>
Weather 表：
+----+------------+-------------+
| id | recordDate | Temperature |
+----+------------+-------------+
| 1  | 2015-01-01 | 10          |
| 2  | 2015-01-02 | 25          |
| 3  | 2015-01-03 | 20          |
| 4  | 2015-01-04 | 30          |
+----+------------+-------------+
<strong>输出：</strong>
+----+
| id |
+----+
| 2  |
| 4  |
+----+
<strong>解释：</strong>
2015-01-02 的温度比前一天高（10 -> 25）
2015-01-04 的温度比前一天高（20 -> 30）</pre>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> w1.id</span><br><span class="line"><span class="keyword">from</span> Weather w1, Weather w2</span><br><span class="line"><span class="keyword">where</span> w1.recordDate <span class="operator">-</span> <span class="type">interval</span> <span class="number">1</span> <span class="keyword">day</span> <span class="operator">=</span> w2.recordDate</span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">w1.temperature <span class="operator">&gt;</span> w2.temperature</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++语法学习笔记（持续更新）</title>
    <url>/2025/02/07/noteC/</url>
    <content><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>C++风格字符串库 <code>#include&lt;cstring&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(_string)</span><br></pre></td></tr></table></figure>

<p>返回：_string长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(_s1, _s2)</span><br></pre></td></tr></table></figure>

<p>功能：将_s2的值复制到_s1，返回值为_s1的地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcmp</span>(str1, str2)</span><br></pre></td></tr></table></figure>

<p>功能：比较str1与str2的值。</p>
<p><strong>逐字符比较</strong> ：</p>
<ul>
<li>从字符串的第一个字符开始，逐个比较 <code>str1</code> 和 <code>str2</code> 中对应位置的字符。</li>
<li>比较的依据是字符的 ASCII 值。</li>
</ul>
<p><strong>返回值规则</strong> ：</p>
<ul>
<li>如果 <code>str1</code> 和 <code>str2</code> 完全相同，返回 <code>0</code>。</li>
<li>如果 <code>str1</code> 的第一个不同字符的 ASCII 值小于 <code>str2</code> 的对应字符，返回一个 <strong>负整数</strong> 。</li>
<li>如果 <code>str1</code> 的第一个不同字符的 ASCII 值大于 <code>str2</code> 的对应字符，返回一个 <strong>正整数</strong> 。</li>
</ul>
<p><strong>结束条件</strong> ：</p>
<ul>
<li>如果其中一个字符串提前结束（遇到 <code>\0</code>），而另一个字符串还有字符，则较短的字符串被认为是“较小”的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strchr</span>(str,ch)</span><br></pre></td></tr></table></figure>

<p>功能：返回str中第一个出现ch字符的地址。未找到则返回 <code>null</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strstr</span>(str1, str2)</span><br></pre></td></tr></table></figure>

<p>功能：返回str1中第一次出现str2的位置。未找到则返回 <code>null</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(str1, str2)</span><br></pre></td></tr></table></figure>

<p>功能：连接两个字符串。</p>
<h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><p>C&#x2F;C++常见修饰符</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th>修饰符功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">const</td>
<td>const 定义常量，表示该变量的值不能被修改。</td>
</tr>
<tr>
<td align="left">volatile</td>
<td>修饰符<strong>volatile</strong> 告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程。。</td>
</tr>
<tr>
<td align="left">restrict</td>
<td>由<strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td>
</tr>
<tr>
<td align="left">mutable</td>
<td>mutable 用于修饰类的成员变量。被 mutable 修饰的成员变量可以被修改，即使它们所在的对象是 const 的。</td>
</tr>
<tr>
<td align="left">static</td>
<td>用于定义静态变量，表示该变量的作用域仅限于当前文件或当前函数内，不会被其他文件或函数访问。</td>
</tr>
<tr>
<td align="left">register</td>
<td>用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率。</td>
</tr>
</tbody></table>
<h2 id="const举例"><a href="#const举例" class="headerlink" title="const举例"></a>const举例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> num1 = <span class="number">11</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>*a = &amp;num</span><br><span class="line">*a = <span class="number">11</span>; <span class="comment">// 报错</span></span><br><span class="line">cout&lt;&lt;*a;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> b = &amp;num</span><br><span class="line">b = num1;<span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="const高级用法"><a href="#const高级用法" class="headerlink" title="const高级用法"></a>const高级用法</h3><blockquote>
<p>暂未补充</p>
</blockquote>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>本质即为存放元素的地址，存在地址的地址即二级地址，以此类推。</p>
<h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p>：：数组存放元素为指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptrs[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	ptrs[i] = &amp;var[i];</span><br><span class="line">	std::cout&lt;&lt;*ptrs[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存放字符串的数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* strs[<span class="number">3</span>] = &#123;</span><br><span class="line">	<span class="string">&quot;AI&quot;</span>,</span><br><span class="line">	<span class="string">&quot;MechineLearn&quot;</span>,</span><br><span class="line">	<span class="string">&quot;DeepLearn&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数返回指针</p>
<blockquote>
<p>函数返回值不能返回局部变量的地址，除非该变量声明为static</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> temp = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//int temp = 1; 则会报错无法返回局部变量值</span></span><br><span class="line">	<span class="keyword">return</span> &amp;temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *var = <span class="literal">nullptr</span>;</span><br><span class="line">	var = <span class="built_in">getValue</span>();<span class="comment">// var被赋值为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li>引用变量是一个别名。</li>
<li>一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</li>
<li>引用必须在定义时初始化，并且一旦绑定到一个变量后，就不能再绑定到其他变量。</li>
</ul>
<p>普通引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">17</span>;</span><br><span class="line"><span class="type">int</span> &amp;cp = num;</span><br></pre></td></tr></table></figure>

<p>数组引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a1[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (&amp;a2)[] = a;</span><br></pre></td></tr></table></figure>

<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>优点：</p>
<ul>
<li><strong>简单数据封装</strong> ：适合封装多种类型的简单数据，通常用于数据的存储。</li>
<li><strong>轻量级</strong> ：相比 <code>class</code>，结构体语法更简洁，适合小型数据对象。</li>
<li><strong>面向对象支持</strong> ：支持构造函数、成员函数和访问权限控制，可以实现面向对象的设计。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">type_name</span> &#123;</span><br><span class="line">type1 member_name1;</span><br><span class="line">type2 member_name2;</span><br><span class="line">type3 member_name3;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">type_name</span> s1&#123;val1,val2,val3&#125;;</span><br><span class="line">	std::cout &lt;&lt; s<span class="number">1.</span>member_name1 &lt;&lt; std::endl; <span class="comment">//结构体成员使用 .</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">type_name</span> *struct_pointer; <span class="comment">//指向结构的指针</span></span><br><span class="line">	struct_pointer = &amp;s1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="typedef关键字"><a href="#typedef关键字" class="headerlink" title="typedef关键字"></a>typedef关键字</h2><p>将类型名取别名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">type_name</span> newType;<span class="comment">// typedef重命名</span></span><br><span class="line"></span><br><span class="line">newType t2;</span><br></pre></td></tr></table></figure>

<h2 id="结构体与类的区别"><a href="#结构体与类的区别" class="headerlink" title="结构体与类的区别"></a>结构体与类的区别</h2><p>在 C++ 中，struct 和 class 本质上非常相似，唯一的区别在于默认的访问权限：</p>
<ul>
<li>struct 默认的成员和继承是 public。</li>
<li>class 默认的成员和继承是 private。</li>
</ul>
<p>可以将 <code>struct</code> 当作一种简化形式的 <code>class</code>，适合用于没有太多复杂功能的简单数据封装。</p>
<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><p>类用于指定对象的形式，是一种用户自定义的数据类型，它是一种封装了数据和函数的组合。类可以被看作是一种模板，可以用来创建具有相同属性和行为的多个对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 访问修饰符：public</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">double</span> length;   <span class="comment">// 长度</span></span><br><span class="line">      <span class="type">double</span> breadth;  <span class="comment">// 宽度</span></span><br><span class="line">      <span class="type">double</span> height;   <span class="comment">// 高度</span></span><br><span class="line">      <span class="comment">// 成员函数声明</span></span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">( <span class="type">double</span> len, <span class="type">double</span> bre, <span class="type">double</span> hei )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 成员函数定义1</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Box::getV</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 成员函数定义2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Box::set</span><span class="params">( <span class="type">double</span> len, <span class="type">double</span> bre, <span class="type">double</span> hei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">    breadth = bre;</span><br><span class="line">    height = hei;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-类访问修饰符"><a href="#C-类访问修饰符" class="headerlink" title="C++ 类访问修饰符"></a>C++ <strong>类访问修饰符</strong></h2><p>关键字 <strong>public、private、protected</strong> 称为访问修饰符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 公有成员</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// 受保护成员</span></span><br><span class="line">  <span class="comment">//与私有成员十分相似，但有一点不同，protected（受保护）成员在子类中是可访问的。</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 私有成员</span></span><br><span class="line">  <span class="comment">//私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。</span></span><br><span class="line">  <span class="comment">//实际操作中，在私有区域定义数据，在公有区域定义相关的函数，在类的外部也可以调用这些函数。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>继承后的特点</p>
<p>有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。</p>
<ul>
<li><strong>public 继承：</strong> 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</li>
<li><strong>protected 继承：</strong> 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</li>
<li><strong>private 继承：</strong> 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</li>
</ul>
<p>但无论哪种继承方式，下面两点都没有改变：</p>
<ul>
<li>private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；</li>
<li>protected 成员可以被派生类访问。</li>
</ul>
<blockquote>
<p>如果继承时不显示声明是  <strong>private，protected，public 继承，则默认是 private 继承，在 struct 中默认 public 继承</strong></p>
</blockquote>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>静态成员函数与普通成员函数的区别：</p>
<ul>
<li>静态成员函数没有 <code>this</code> 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</li>
<li>普通成员函数有 <code>this</code>指针，可以访问类中的任意成员；而静态成员函数没有 <code>this</code>指针。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 静态成员变量</span></span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> objCount;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">        <span class="built_in">Father</span>();</span><br><span class="line">	<span class="comment">// 析构函数 </span></span><br><span class="line">        ~<span class="built_in">Father</span>(); </span><br><span class="line">	<span class="comment">// 友元函数 </span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GN</span><span class="params">(Father *f)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意：初始化类的静态成员</span></span><br><span class="line"><span class="type">int</span> Father::objCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>静态成员变量可以使用 <code>类名::静态变量</code>访问，静态成员函数无法使用 <code>this</code>。</p>
<h2 id="C-类成员函数"><a href="#C-类成员函数" class="headerlink" title="C++ 类成员函数"></a>C++ <strong>类成员函数</strong></h2><p>成员函数可以定义在类定义内部，或者单独使用<strong>范围解析运算符 ::</strong> 来定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="type">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="type">double</span> height;      <span class="comment">// 高度</span></span><br><span class="line">      <span class="comment">// 定义在类定义内部</span></span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">getVolume</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义在类定义外部</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Box::getVolume</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>使用初始化列表来初始化字段。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span>*name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Father</span>(<span class="type">char</span>*n1); </span><br><span class="line">        <span class="function"><span class="type">char</span>* <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Father::<span class="built_in">Father</span>(<span class="type">char</span>*n1,<span class="type">int</span> a):<span class="built_in">name</span>(n1),<span class="built_in">age</span>(a)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;oh~ god!!!!:&quot;</span>&lt;&lt; name &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>若空构造函数声明则必须实现。</p>
</blockquote>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>类的<strong>析构函数</strong>是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数，在创建时执行</span></span><br><span class="line">        <span class="built_in">Father</span>(); </span><br><span class="line">	<span class="comment">// 析构函数，在删除时执行</span></span><br><span class="line">        ~<span class="built_in">Father</span>();</span><br><span class="line">&#125;;</span><br><span class="line">Father::<span class="built_in">Father</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;oh~ new！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">Father::~<span class="built_in">Father</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;oh~ delete！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p>
<ul>
<li>通过使用另一个同类型的对象来初始化新创建的对象。</li>
<li>复制对象把它作为参数传递给函数。</li>
<li>复制对象，并从函数返回这个对象。</li>
</ul>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。</p>
<blockquote>
<p>尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p>
</blockquote>
<p>如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 <strong><code>friend</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span>*name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Father</span>(<span class="type">char</span>*n1,<span class="type">int</span> tag); </span><br><span class="line">        ~<span class="built_in">Father</span>(); </span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GN</span><span class="params">(Father *f)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">char</span>* <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GN</span><span class="params">(Father *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;f-&gt;name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;f-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Father *f1 = <span class="keyword">new</span> <span class="built_in">Father</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">GN</span>(f1);<span class="comment">// --&gt; abc 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为 <strong>基类</strong> ，新建的类称为 <strong>派生类</strong> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// eat() 函数</span></span><br><span class="line">    <span class="comment">// sleep() 函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line">    <span class="comment">// bark() 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>基类的静态成员也可被继承，并且公用一处内存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">        <span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::count = <span class="number">0</span>;</span><br><span class="line">A::<span class="built_in">A</span>()&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">cout&lt;&lt;A::count&lt;&lt;endl;<span class="comment">// -&gt; 1</span></span><br><span class="line">cout&lt;&lt;AA::count&lt;&lt;endl;<span class="comment">// -&gt; 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><strong>多态</strong>按字面的意思就是多种形态。</p>
<p>以下是多态的几个关键点：</p>
<p> <strong>虚函数（Virtual Functions）</strong> ：</p>
<ul>
<li>在基类中声明一个函数为虚函数，使用关键字 <code>virtual</code>。</li>
<li>派生类可以重写（override）这个虚函数。</li>
<li>调用虚函数时，会根据对象的实际类型来决定调用哪个版本的函数。</li>
</ul>
<p> <strong>动态绑定（Dynamic Binding）</strong> ：</p>
<ul>
<li>也称为晚期绑定（Late Binding），在运行时确定函数调用的具体实现。</li>
<li>需要使用指向基类的指针或引用来调用虚函数，编译器在运行时根据对象的实际类型来决定调用哪个函数。</li>
</ul>
<p> <strong>纯虚函数（Pure Virtual Functions）</strong> ：</p>
<ul>
<li>一个包含纯虚函数的类被称为抽象类（Abstract Class），它不能被直接实例化。</li>
<li>纯虚函数没有函数体，声明时使用 <code>= 0</code>。</li>
<li>它强制派生类提供具体的实现。</li>
</ul>
<p> <strong>多态的实现机制</strong> ：</p>
<ul>
<li>虚函数表（V-Table）：C++运行时使用虚函数表来实现多态。每个包含虚函数的类都有一个虚函数表，表中存储了指向类中所有虚函数的指针。</li>
<li>虚函数指针（V-Ptr）：对象中包含一个指向该类虚函数表的指针。</li>
</ul>
<p> <strong>使用多态的优势</strong> ：</p>
<ul>
<li><strong>代码复用</strong> ：通过基类指针或引用，可以操作不同类型的派生类对象，实现代码的复用。</li>
<li><strong>扩展性</strong> ：新增派生类时，不需要修改依赖于基类的代码，只需要确保新类正确重写了虚函数。</li>
<li><strong>解耦</strong> ：多态允许程序设计更加模块化，降低类之间的耦合度。</li>
</ul>
<p> <strong>注意事项</strong> ：</p>
<ul>
<li>只有通过基类的指针或引用调用虚函数时，才会发生多态。</li>
<li>如果直接使用派生类的对象调用函数，那么调用的是派生类中的版本，而不是基类中的版本。</li>
<li>多态性需要运行时类型信息（RTTI），这可能会增加程序的开销。</li>
</ul>
<p>通过基类指针调用不同的派生类方法，展示了多态的动态绑定特性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> L;</span><br><span class="line">        <span class="type">int</span> W;</span><br><span class="line">        <span class="built_in">A</span>();</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> l, <span class="type">int</span> w):<span class="built_in">L</span>(l), <span class="built_in">W</span>(w)&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::area</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L+W;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Aa</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> L*W;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Aa</span>(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ab</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> L/W;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Ab</span>(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 委托基类构造派生类</span></span><br><span class="line">Aa::<span class="built_in">Aa</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">A</span>(a,b) &#123;&#125;</span><br><span class="line">Ab::<span class="built_in">Ab</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">A</span>(a,b) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="literal">nullptr</span>;</span><br><span class="line">    Aa aa&#123;<span class="number">10</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    Ab bb&#123;<span class="number">10</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    a = &amp;aa;<span class="comment">// 基类指针更换绑定，体现多态</span></span><br><span class="line">    cout&lt;&lt;a-&gt;<span class="built_in">area</span>()&lt;&lt;endl;</span><br><span class="line">    a = &amp;bb;<span class="comment">// 基类指针更换绑定，体现多态</span></span><br><span class="line">    cout&lt;&lt;a-&gt;<span class="built_in">area</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>纯虚函数是没有实现的虚函数，在基类中用 <strong><code>= 0</code></strong> 来声明。</p>
<p>纯虚函数表示基类定义了一个接口，但具体实现由派生类负责。</p>
<p>纯虚函数使得基类变为抽象类（abstract class），无法实例化。</p>
<p> <strong>特点：</strong></p>
<ul>
<li><strong>必须在基类中声明为 <code>= 0</code></strong> ，表示没有实现，子类必须重写。</li>
<li><strong>抽象类</strong> ：包含纯虚函数的类不能直接实例化，必须通过派生类实现所有纯虚函数才能创建对象。</li>
<li><strong>接口定义</strong> ：纯虚函数通常用于定义接口，让派生类实现具体行为。</li>
</ul>
<h3 id="虚函数与纯虚函数的对比"><a href="#虚函数与纯虚函数的对比" class="headerlink" title="虚函数与纯虚函数的对比"></a>虚函数与纯虚函数的对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>虚函数（Virtual Function）</th>
<th>纯虚函数（Pure Virtual Function）</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>基类中使用 <code>virtual</code> 声明，可以有实现</td>
<td>基类中使用 <code>= 0</code> 声明，无实现</td>
</tr>
<tr>
<td>子类重写</td>
<td>子类可以选择重写</td>
<td>子类必须实现</td>
</tr>
<tr>
<td>抽象性</td>
<td>可以实例化类</td>
<td>使类变为抽象类，无法实例化</td>
</tr>
<tr>
<td>用途</td>
<td>提供默认行为，允许子类重写</td>
<td>定义接口，强制子类实现具体行为</td>
</tr>
</tbody></table>
<h1 id="重载运算符和重载函数"><a href="#重载运算符和重载函数" class="headerlink" title="重载运算符和重载函数"></a>重载运算符和重载函数</h1><p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setW</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">	<span class="comment">// 重载 + 声明</span></span><br><span class="line">        A <span class="keyword">operator</span>+(<span class="type">const</span> A &amp;a); </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">printInf</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::setW</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;w = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载 + 实现</span></span><br><span class="line">A A::<span class="keyword">operator</span>+(<span class="type">const</span> A &amp;a)&#123;</span><br><span class="line">    A tem;</span><br><span class="line">    tem.w = <span class="keyword">this</span>-&gt;w + a.w;</span><br><span class="line">    <span class="keyword">return</span> tem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::printInf</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="keyword">this</span>-&gt;w&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2;</span><br><span class="line">    a<span class="number">1.</span><span class="built_in">setW</span>(<span class="number">100</span>);</span><br><span class="line">    a<span class="number">2.</span><span class="built_in">setW</span>(<span class="number">1000</span>);</span><br><span class="line">    A a3 = a1+a2;</span><br><span class="line">    a<span class="number">3.</span><span class="built_in">printInf</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可重载运算符-不可重载运算符"><a href="#可重载运算符-不可重载运算符" class="headerlink" title="可重载运算符&#x2F;不可重载运算符"></a>可重载运算符&#x2F;不可重载运算符</h2><p>下面是可重载的运算符列表：</p>
<table>
<thead>
<tr>
<th>运算符列表</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>双目算术运算符</td>
<td>+ (加)，-(减)，*(乘)，&#x2F;(除)，% (取模)</td>
</tr>
<tr>
<td>关系运算符</td>
<td>&#x3D;&#x3D;(等于)，!&#x3D; (不等于)，&lt; (小于)，&gt; (大于)，&lt;&#x3D;(小于等于)，&gt;&#x3D;(大于等于)</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>(逻辑或)，(逻辑与)，(逻辑非)</td>
</tr>
<tr>
<td>单目运算符</td>
<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>
</tr>
<tr>
<td>自增自减运算符</td>
<td>++(自增)，–(自减)</td>
</tr>
<tr>
<td>位运算符</td>
<td>(按位或)， (按位与)，(按位取反)，(按位异或),， (左移)，(右移)</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>&#x3D;, +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D; , % &#x3D; , &amp;&#x3D;,</td>
</tr>
<tr>
<td>空间申请与释放</td>
<td>new, delete, new[ ] , delete[]</td>
</tr>
<tr>
<td>其他运算符</td>
<td><strong>()</strong>(函数调用)，<strong>-&gt;</strong>(成员访问)，<strong>,</strong>(逗号)，<strong>[]</strong>(下标)</td>
</tr>
</tbody></table>
<p>下面是不可重载的运算符列表：</p>
<ul>
<li><strong>.</strong>：成员访问运算符</li>
<li><strong>.</strong>*, -&gt; *：成员指针访问运算符</li>
<li><strong>::</strong>：域运算符</li>
<li><strong>sizeof</strong>：长度运算符</li>
<li><strong>?:</strong>：条件运算符</li>
<li><strong>#</strong>： 预处理符号</li>
</ul>
<h1 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// []      // 沒有定义任何变量。使用未定义变量会引发错误。</span></span><br><span class="line"><span class="comment">// [x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。</span></span><br><span class="line"><span class="comment">// [&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。</span></span><br><span class="line"><span class="comment">// [=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。</span></span><br><span class="line"><span class="comment">// [&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span></span><br><span class="line"><span class="comment">// [=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br><span class="line"><span class="keyword">auto</span> func = [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123; <span class="type">int</span> z = x + y; <span class="keyword">return</span> z + x; &#125;;<span class="comment">//z = 1+2,ret=3+1</span></span><br></pre></td></tr></table></figure>

<h1 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h1><p> 引入内联函数的目的是为了解决程序中函数调用的效率问题，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：</p>
<ul>
<li>1.在内联函数内不允许使用循环语句和开关语句；</li>
<li>2.内联函数的定义必须出现在内联函数第一次调用之前；</li>
<li>3.类结构中所在的类说明内部定义的函数是内联函数。</li>
</ul>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 迭代访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it!=vec.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 范围访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> ele : vec)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;ele&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除第index+1个元素</span></span><br><span class="line">vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>()+index);</span><br><span class="line"><span class="comment">// 清除</span></span><br><span class="line">vec.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3学习记录</title>
    <url>/2025/03/11/webNote/</url>
    <content><![CDATA[<h1 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h1><p>关键属性：<code>float</code></p>
<p>值：left、right</p>
<p>清除浮动：本质是闭合浮动</p>
<ul>
<li>方法1：overflow: hidden</li>
<li>方法2：伪元素</li>
<li>方法3</li>
<li>方法4</li>
</ul>
<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>关键属性：<code>position</code></p>
<p>值：static、relative、absolute、fixed、sticky</p>
<blockquote>
<p>子绝父相</p>
</blockquote>
<p>相对定位可以使用 <code>margin:auto</code>设置居中，绝对定位无法使用，需要计算设置</p>
<h2 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h2><p>z-index:提高层级</p>
<p>display：none</p>
<p>visibility：visible &#x2F; hidden</p>
<p>overflow：</p>
<h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><h1 id="CSS3结构伪类选择器"><a href="#CSS3结构伪类选择器" class="headerlink" title="CSS3结构伪类选择器"></a>CSS3结构伪类选择器</h1><p>E::first-child</p>
<p>E::last-child</p>
<p>E:nth-child：nth-child(even)、nth-child(odd)、nth-child(表达式)[n,2n,2n-1,n+1,-n+1] 指定元素E的第几个，先匹配类型后匹配几个</p>
<p>E:nth-of-type(): 指定元素E的第几个，先匹配指定元素后匹配类型</p>
<h1 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h1><p>并不是真正元素，在文档中找不到。</p>
<p>E::before()</p>
<p>E::after()</p>
<p>都必须存在content属性</p>
<h1 id="CSS3盒模型"><a href="#CSS3盒模型" class="headerlink" title="CSS3盒模型"></a>CSS3盒模型</h1><p>box-size：border-size、content-size</p>
<h1 id="css3其他特性"><a href="#css3其他特性" class="headerlink" title="css3其他特性"></a>css3其他特性</h1><p>calc(): calc(100%-15px)</p>
<p>filter: blur(15px)</p>
<p>transition: 变化属性  花费时间 运动曲线 开始时间</p>
<p>transition: all</p>
<p><strong>动画：</strong></p>
<p>定义动画</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@keyframes 动画名</span><br><span class="line">&#123;</span><br><span class="line"> 	0%&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	100%&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配合使用属性</p>
<p><code>animation-name</code></p>
<p><code>animation-duration</code></p>
<p>translate()：移动元素，并不会改变其他盒子</p>
<p>animation属性</p>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>RESTful API介绍</title>
    <url>/2025/04/04/RESTfulAPI/</url>
    <content><![CDATA[<h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RESTful API 是一种基于 <strong>REST（Representational State Transfer）</strong> 架构风格设计的接口，核心特点包括：</p>
<ol>
<li><strong>资源导向</strong>：通过 URL 定位资源（如 <code>/users</code> 表示用户）。</li>
<li><strong>HTTP 方法</strong>：用 <code>GET</code>&#x2F;<code>POST</code>&#x2F;<code>PUT</code>&#x2F;<code>DELETE</code> 对应资源的 <strong>查增改删</strong>（CRUD）。</li>
<li><strong>无状态</strong>：每次请求包含足够信息，服务端不保存客户端状态。</li>
<li><strong>返回格式</strong>：通常返回 JSON&#x2F;XML 格式数据。</li>
</ol>
<blockquote>
<p>**RESTful 是一种****后端接口架构风格**，定义如何通过 HTTP 协议暴露资源（如用户、订单等）。</p>
</blockquote>
<hr>
<h2 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h2><table>
<thead>
<tr>
<th><strong>操作类型</strong></th>
<th><strong>HTTP 方法</strong></th>
<th><strong>URL 示例</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>查询列表</strong></td>
<td><code>GET</code></td>
<td><code>/users</code></td>
<td><strong>获取所有用户</strong></td>
</tr>
<tr>
<td><strong>查询单个</strong></td>
<td><code>GET</code></td>
<td><code>/users/:id</code></td>
<td><strong>获取 ID 为 1 的用户</strong></td>
</tr>
<tr>
<td><strong>新增</strong></td>
<td><code>POST</code></td>
<td><code>/users</code></td>
<td><strong>创建新用户</strong></td>
</tr>
<tr>
<td><strong>修改全部</strong></td>
<td><code>PUT</code></td>
<td><code>/users/:id</code></td>
<td><strong>替换 ID 为 1 的用户数据</strong></td>
</tr>
<tr>
<td><strong>修改部分</strong></td>
<td><code>PATCH</code></td>
<td><code>/users/:id</code></td>
<td><strong>更新 ID 为 1 的用户部分字段</strong></td>
</tr>
<tr>
<td><strong>删除</strong></td>
<td><code>DELETE</code></td>
<td><code>/users/:id</code></td>
<td><strong>删除 ID 为 1 的用户</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote>
<p><strong>基于 Express5.x 框架</strong></p>
</blockquote>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h3 id="实现-CRUD-接口"><a href="#实现-CRUD-接口" class="headerlink" title="实现 CRUD 接口"></a>实现 CRUD 接口</h3><p><strong>查询所有用户</strong></p>
<p><strong>查询单个用户</strong></p>
<p><strong>创建用户</strong></p>
<p><strong>更新用户</strong></p>
<p><strong>删除用户</strong></p>
]]></content>
      <categories>
        <category>标准</category>
      </categories>
      <tags>
        <tag>RESTful-API</tag>
      </tags>
  </entry>
  <entry>
    <title>React使用手册</title>
    <url>/2025/04/08/React/</url>
    <content><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="Next-js"><a href="#Next-js" class="headerlink" title="Next.js"></a>Next.js</h2><p><strong>Next.js 的页面路由 是一个全栈的 React 框架。它用途广泛，可让你创建任何规模的 React 应用程序——从大部分的静态博客到复杂的动态应用程序。要创建新的 Next.js 项目，请在终端中运行：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx create-next-app@latest</span><br></pre></td></tr></table></figure>

<h2 id="Vite-构建环境"><a href="#Vite-构建环境" class="headerlink" title="Vite 构建环境"></a>Vite 构建环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm create vite@latest my-react-app --template react</span><br><span class="line"># 或使用 TypeScript</span><br><span class="line">npm create vite@latest my-react-app --template react-ts</span><br></pre></td></tr></table></figure>

<h2 id="UI-树"><a href="#UI-树" class="headerlink" title="UI 树"></a>UI 树</h2><p><strong>React 使用树形关系建模以展示组件和模块之间的关系。</strong></p>
<p><strong>位于树顶部、靠近根组件的组件被视为顶层组件。没有子组件的组件被称为叶子组件。对组件的这种分类对于理解数据流和渲染性能非常有用。</strong></p>
<h2 id="JSX-编写标签"><a href="#JSX-编写标签" class="headerlink" title="JSX 编写标签"></a>JSX 编写标签</h2><blockquote>
<p>**React 组件是常规的 JavaScript 函数，但 ****组件的名称必须以大写字母开头**，否则它们将无法运行！</p>
</blockquote>
<h3 id="大括号使用："><a href="#大括号使用：" class="headerlink" title="大括号使用："></a>大括号使用：</h3><p><strong>css 内联样式：内联 <strong><code>style</code> 属性 使用</strong>驼峰命名法</strong>编写。例如，HTML</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul style=&quot;background-color: black&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>**在你的组件里应该写成 **</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul style=&#123;&#123; backgroundColor: &#x27;black&#x27; &#125;&#125;&gt;</span><br></pre></td></tr></table></figure>

<p>**所以当你下次在 JSX 中看到 **<code>&#123;&#123;` 和 `&#125;&#125;</code>时，就知道它只不过是包在大括号里的一个对象罢了！</p>
<h3 id="Fragment-语法"><a href="#Fragment-语法" class="headerlink" title="Fragment 语法"></a>Fragment 语法</h3><p>**使用 Fragment 可以将多个组件包裹（通常写作 **<code>&lt;&gt;</code>）， 包裹 JSX 节点可以避免引入额外的 <code>div</code> 元素！</p>
<h2 id="props-组件通信"><a href="#props-组件通信" class="headerlink" title="props 组件通信"></a>props 组件通信</h2><h3 id="传递值"><a href="#传递值" class="headerlink" title="传递值"></a>传递值</h3><h3 id="传递对象"><a href="#传递对象" class="headerlink" title="传递对象"></a>传递对象</h3><h3 id="传递-children"><a href="#传递-children" class="headerlink" title="传递 children"></a>传递 children</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Card(&#123; children &#125;: &#123; children: any &#125;) &#123;</span><br><span class="line">  return &lt;div&gt;&#123;children&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function CardChildren() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line">      &lt;p&gt;传递children&lt;/p&gt;</span><br><span class="line">      &lt;Card&gt;</span><br><span class="line">        &lt;p&gt;我是孩子内的内容&lt;/p&gt;</span><br><span class="line">      &lt;/Card&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p><strong>切勿将数字放在 <code>&amp;&amp;</code> 左侧.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface arg1 &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  isTrue: boolean;</span><br><span class="line">&#125;</span><br><span class="line">function MyItem(&#123; name, isTrue &#125;: arg1) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">      &#123;name&#125;:&#123;isTrue &amp;&amp; &quot;√&quot;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">function MyList() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;MyItem name=&quot;a&quot; isTrue=&#123;true&#125; /&gt;</span><br><span class="line">        &lt;MyItem name=&quot;b&quot; isTrue=&#123;true&#125; /&gt;</span><br><span class="line">        &lt;MyItem name=&quot;c&quot; isTrue=&#123;false&#125; /&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">export default MyList;</span><br></pre></td></tr></table></figure>

<h2 id="渲染列表"><a href="#渲染列表" class="headerlink" title="渲染列表"></a>渲染列表</h2><ul>
<li><strong>每日一个小知识：</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">()=&gt;&#123;&#125;// 无返回值</span><br><span class="line">()=&gt;()// 返回值为null</span><br><span class="line">//如上两种写法不同</span><br><span class="line">()=&gt;&#123;return &#x27;ok&#x27;&#125;</span><br><span class="line">// 等价于</span><br><span class="line">()=&gt;&#x27;ok&#x27;</span><br><span class="line">//或者</span><br><span class="line">()=&gt;(&#x27;ok&#x27;)</span><br><span class="line"></span><br><span class="line">// ------------------------------</span><br><span class="line">const people = [</span><br><span class="line">&#123;id:1&#125;,</span><br><span class="line">&#123;id:2&#125;,</span><br><span class="line">...</span><br><span class="line">]</span><br><span class="line">// 过滤器</span><br><span class="line">const idEqual1 = people.filter(p=&gt;p.id===1)</span><br><span class="line">/// map遍历</span><br><span class="line">const peopleList = people.map(</span><br><span class="line">    p=&gt;</span><br><span class="line">    &lt;li&gt;&#123;p.id&#125;&lt;/li&gt;</span><br><span class="line">)</span><br><span class="line">// 这渲染起来看上去像</span><br><span class="line">//&lt;li&gt;1&lt;/li&gt;</span><br><span class="line">//&lt;li&gt;2&lt;/li&gt;</span><br><span class="line">//&lt;li&gt;..&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<p><strong>关于 js 中 Array.map 函数的使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const newArray = arr.map(callback(currentValue, index, array), thisArg)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>callback</code></strong>：处理每个元素的函数，接收三个参数：<ul>
<li><code>currentValue</code>：当前处理的元素（必选）</li>
<li><code>index</code>：当前元素的索引（可选）</li>
<li><code>array</code>：原数组（可选）</li>
</ul>
</li>
<li><strong><code>thisArg</code></strong>（可选）：指定 <code>callback</code> 里的 <code>this</code> 指向（一般很少用）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface item &#123;</span><br><span class="line">  id: number;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line">const lists: Array&lt;item&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: 1,</span><br><span class="line">    name: &quot;a&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: 2,</span><br><span class="line">    name: &quot;bb&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line">function MapList() &#123;</span><br><span class="line">  const listItems = lists.map((person) =&gt; (</span><br><span class="line">    &lt;li key=&#123;person.id&#125;&gt;</span><br><span class="line">      &#123;person.id&#125;:&#123;person.name&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  ));</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default MapList;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="保持组件纯粹"><a href="#保持组件纯粹" class="headerlink" title="保持组件纯粹"></a>保持组件纯粹</h2><p><strong>保持组件不改变引用的值。防止渲染出现错误。</strong></p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>**React 提供了 “严格模式”，在严格模式下开发时，它将会调用每个组件函数两次。****通过重复调用组件函数，严格模式有助于找到违反这些规则的组件**。</p>
<p>**严格模式在生产环境下不生效，因此它不会降低应用程序的速度。如需引入严格模式，你可以用 **<code>&lt;React.StrictMode&gt;</code> 包裹根组件。一些框架会默认这样做。</p>
<h4 id="Key-的作用"><a href="#Key-的作用" class="headerlink" title="Key 的作用"></a>Key 的作用</h4><ul>
<li><code>key</code> 帮助 React 识别哪些元素被<strong>添加、修改或删除</strong>，从而提高 <code>diff</code> 算法的效率。</li>
<li>**它用于****同级元素**的列表（如 <code>map</code> 或循环生成的组件）。</li>
<li><strong>一个组件必须是纯粹的，就意味着：</strong><ul>
<li><strong>只负责自己的任务。</strong> 它不会更改在该函数调用前就已存在的对象或变量。</li>
<li><strong>输入相同，则输出相同。</strong> 给定相同的输入，组件应该总是返回相同的 JSX。</li>
</ul>
</li>
</ul>
<h2 id="添加交互"><a href="#添加交互" class="headerlink" title="添加交互"></a>添加交互</h2><p><strong>小知识：</strong></p>
<ul>
<li><code>event.preventDefault();</code>阻止事件的默认行为，比如阻止 submit 按钮的提交表单。</li>
<li>**如果在代码中复制对象感觉乏味，可以使用 **<a href="https://github.com/immerjs/use-immer">Immer</a> 之类的库来减少重复代码。</li>
</ul>
<h3 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h3><p><strong>事件处理函数有如下特点:</strong></p>
<ul>
<li>**通常在你的组件 ****内部** 定义。</li>
<li>**名称以 **<code>handle</code> 开头，后跟事件名称。</li>
<li><strong>然后 将其作为 prop 传入。</strong></li>
</ul>
<blockquote>
<p><strong>事件传递顺序：事件处理函数还将捕获任何来自子组件的事件。通常，我们会说事件会沿着树向上“冒泡”或“传播”：它从事件发生的地方开始，然后沿着树向上传播。</strong></p>
</blockquote>
<p><strong>若要阻止事件向上传递，使用</strong> <code>event.stopPropagation();</code></p>
<p><strong>捕获子元素的所有事件：</strong></p>
<p>**极少数情况下，你可能需要捕获子元素上的所有事件，****即便它们阻止了传播**。例如，你可能想对每次点击进行埋点记录，传播逻辑暂且不论。那么你可以通过在事件名称末尾添加 <code>Capture</code> 来实现这一点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div onClickCapture=&#123;() =&gt; &#123; /* 这会首先执行 */ &#125;&#125;&gt;</span><br><span class="line">  &lt;button onClick=&#123;e =&gt; e.stopPropagation()&#125; /&gt;</span><br><span class="line">  &lt;button onClick=&#123;e =&gt; e.stopPropagation()&#125; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>每个事件分三个阶段传播：</strong></p>
<ol>
<li>**它向下传播，调用所有的 **<code>onClickCapture</code> 处理函数。</li>
<li>**它执行被点击元素的 **<code>onClick</code> 处理函数。</li>
<li>**它向上传播，调用所有的 **<code>onClick</code> 处理函数。</li>
</ol>
<p><strong>捕获事件对于路由或数据分析之类的代码很有用，但你可能不会在应用程序代码中使用它们。</strong></p>
<p><strong>阻止默认行为：</strong><code>event.preventDefault();</code></p>
<blockquote>
<p><strong>不要混淆 e.stopPropagation() 和 e.preventDefault()。它们都很有用，但二者并不相关：</strong></p>
<ul>
<li><strong>e.stopPropagation() 阻止触发绑定在外层标签上的事件处理函数。</strong></li>
<li><strong>e.preventDefault() 阻止少数事件的默认浏览器行为。</strong></li>
</ul>
</blockquote>
<p><strong>副作用</strong></p>
<p><strong>事件处理函数是最佳的执行副作用的位置，但是，为了更改某些信息，你首先需要某种方式存储它。在 React 中，这是通过 state（组件的记忆） 来完成的。</strong></p>
<h3 id="更新函数"><a href="#更新函数" class="headerlink" title="更新函数"></a>更新函数</h3><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p><strong>来看存在问题的代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function StateClick() &#123;</span><br><span class="line">  let num = 0;</span><br><span class="line">  const doClick = () =&gt; &#123;</span><br><span class="line">    num += 1;</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line">      &lt;p&gt;&#123;num&#125;&lt;/p&gt;</span><br><span class="line">      &lt;MyButton onClick=&#123;doClick&#125;&gt;点我看看能不能改变num&lt;/MyButton&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">const MyButton = (&#123; onClick, children &#125;) =&gt; (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;button onClick=&#123;onClick&#125;&gt;&#123;children&#125;&lt;/button&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>显然并不可以改变 num 的值。原因如下：</strong></p>
<ol>
<li><strong>局部变量无法在多次渲染中持久保存。</strong> 当 React 再次渲染这个组件时，它会从头开始渲染——不会考虑之前对局部变量的任何更改。</li>
<li><strong>更改局部变量不会触发渲染。</strong> React 没有意识到它需要使用新数据再次渲染组件。</li>
</ol>
<p><strong>要使用新数据更新组件，需要做两件事：</strong></p>
<ol>
<li><strong>保留</strong> 渲染之间的数据。</li>
<li><strong>触发</strong> React 使用新数据渲染组件（重新渲染）。</li>
</ol>
<p><code>useState Hook</code> 提供了这两个功能：</p>
<ol>
<li><strong>State</strong> 变量 用于保存渲染间的数据。</li>
<li><strong>State setter</strong> 函数 更新变量并触发 React 再次渲染组件。</li>
<li>**惯例是将这对返回值命名为 **<code>const [thing, setThing]</code></li>
<li><code>useState</code> 的唯一参数是 state 变量的<strong>初始值</strong>。</li>
</ol>
<h3 id="渲染与提交"><a href="#渲染与提交" class="headerlink" title="渲染与提交"></a>渲染与提交</h3><p><strong>渲染的时机：</strong></p>
<ul>
<li><strong>组件初次渲染。</strong></li>
<li><strong>组件或者其先祖之一的状态发生了改变。</strong></li>
</ul>
<blockquote>
<p><strong>性能优化：如果更新的组件在树中的位置非常高，渲染更新后的组件内部所有嵌套组件的默认行为将不会获得最佳性能。</strong></p>
<p><strong>不要过早进行优化！</strong></p>
</blockquote>
<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p><strong>State 像是一张快照，设置它不会改变已有的 state 变量，但会触发重新渲染。</strong></p>
<h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p><strong>在 React 中，</strong><code>useState</code> 以及任何其他以“<code>use</code>”开头的函数都被称为 <strong>Hook</strong>。</p>
<p><code>Hook</code>是特殊的函数，只在 React 渲染时有效。它们能让你 “hook” 到不同的 React 特性中去。</p>
<blockquote>
<p><strong>Hooks ——以 <code>use</code> 开头的函数——只能在组件或自定义 Hook 的最顶层调用。</strong> 你不能在<strong>条件语句</strong>、<strong>循环语句</strong>或其他<strong>嵌套函数</strong>内调用 Hook。Hook 是函数，但将它们视为关于组件需求的无条件声明会很有帮助。在组件顶部 “use” React 特性，类似于在文件顶部“导入”模块。</p>
</blockquote>
<hr>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Cup(&#123;guest &#125;) &#123;</span><br><span class="line">  return &lt;h2&gt;Tea cup&#123;id&#125; for guest #&#123;guest&#125;&lt;/h2&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function TeaGathering() &#123;</span><br><span class="line">  let cups = [];</span><br><span class="line">  for (let i = 1; i &lt;= 12; i++) &#123;</span><br><span class="line">    cups.push(&lt;Cup key=&#123;i&#125; guest=&#123;i&#125; /&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">  return cups;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>在 React 中，</strong><code>key</code> 是一个特殊的 prop，<strong>它不会传递给子组件</strong>（即子组件无法直接通过 <code>props.key</code> 访问）。这是 React 的刻意设计，因为 <code>key</code> 是 React 内部用于<strong>优化渲染性能</strong>的标识符，而不是组件逻辑的一部分。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3使用手册</title>
    <url>/2025/04/05/Vue3/</url>
    <content><![CDATA[<h1 id="项目开发过程"><a href="#项目开发过程" class="headerlink" title="项目开发过程"></a>项目开发过程</h1><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p><strong>vue3+typescript</strong></p>
<p><strong>vite 构建，打包</strong></p>
<p><strong>axios 网络请求</strong></p>
<p><strong>ant design for vue 组件库</strong></p>
<p><strong>pinia 全局状态管理</strong></p>
<p><strong>mock 技术</strong></p>
<h2 id="构建-vue-环境"><a href="#构建-vue-环境" class="headerlink" title="构建 vue 环境"></a>构建 vue 环境</h2><p><strong>通过脚手架创建 vue 环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm create vue@latest</span><br></pre></td></tr></table></figure>

<p><strong>通过以下步骤安装依赖并启动开发服务器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &lt;your-project-name&gt;</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<h2 id="vue-项目创建"><a href="#vue-项目创建" class="headerlink" title="vue 项目创建"></a>vue 项目创建</h2><p>**每个 Vue 应用都是通过 **<a href="https://cn.vuejs.org/api/application.html#createapp"><code>createApp</code></a> 函数创建一个新的 <strong>应用实例</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const app = createApp(&#123;</span><br><span class="line">  /* 根组件选项 */</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="根组件"><a href="#根组件" class="headerlink" title="根组件"></a>根组件</h3><p>**我们传入 **<code>createApp</code> 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。</p>
<p><strong>如果你使用的是单文件组件，我们可以直接从另一个文件中导入根组件。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">// 从一个单文件组件中导入根组件</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line"></span><br><span class="line">const app = createApp(App)</span><br></pre></td></tr></table></figure>

<p><strong>虽然本指南中的许多示例只需要一个组件，但大多数真实的应用都是由一棵嵌套的、可重用的组件树组成的。例如，一个待办事项 (Todos) 应用的组件树可能是这样的：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">App (root component)</span><br><span class="line">├─ TodoList</span><br><span class="line">│  └─ TodoItem</span><br><span class="line">│     ├─ TodoDeleteButton</span><br><span class="line">│     └─ TodoEditButton</span><br><span class="line">└─ TodoFooter</span><br><span class="line">   ├─ TodoClearButton</span><br><span class="line">   └─ TodoStatistics</span><br></pre></td></tr></table></figure>

<h3 id="挂载应用"><a href="#挂载应用" class="headerlink" title="挂载应用"></a>挂载应用</h3><p>**应用实例必须在调用了 **<code>.mount()</code> 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- xxx.html --&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// .ts</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>

<p>**应用根组件的内容将会被渲染在容器元素里面。容器元素自己将****不会**被视为应用的一部分。</p>
<p>**当根组件没有设置 **<code>template</code> 选项时，Vue 将自动使用容器的 <code>innerHTML</code> 作为模板。</p>
<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="文本插值"><a href="#文本插值" class="headerlink" title="文本插值"></a>文本插值</h3><p><strong>最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 (即双大括号)：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p><strong>双大括号标签会被替换为相应组件实例中 msg 属性的值。同时每次 msg 属性更改时它也会同步更新。</strong></p>
<h3 id="原始-html"><a href="#原始-html" class="headerlink" title="原始 html"></a>原始 html</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const rawHtml: string =</span><br><span class="line">  &#x27;&lt;span style=&quot;color: red&quot;&gt;This should be red.&lt;/span&gt;&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Using text interpolation: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p><strong>页面渲染为:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Using text interpolation: `&lt;span style=&quot;color: red&quot;&gt;`This should be red.</span><br><span class="line"></span><br><span class="line">Using v-html directive: This should be red.</span><br></pre></td></tr></table></figure>

<h3 id="Attribute-绑定"><a href="#Attribute-绑定" class="headerlink" title="Attribute 绑定"></a>Attribute 绑定</h3><p>**双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 **<code>v-bind</code> 指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-bind</code> 指令指示 Vue 将元素的 <code>id</code> attribute 与组件的 <code>dynamicId</code> 属性保持一致。如果绑定的值是 <code>null</code> 或者 <code>undefined</code>，那么该 attribute 将会从渲染的元素上移除。</p>
<p><strong>简写</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 与 :id=&quot;id&quot; 相同 --&gt;</span><br><span class="line">&lt;div :id&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>动态绑定类标签</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// .ts</span><br><span class="line">const isActive = ref(true)</span><br><span class="line">const hasError = ref(false)</span><br><span class="line">// .html</span><br><span class="line">&lt;div</span><br><span class="line">  class=&quot;static&quot;</span><br><span class="line">  :class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span><br><span class="line">&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>渲染的结果为：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>也可直接用一个完整对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// .ts</span><br><span class="line">const classObject = reactive(&#123;</span><br><span class="line">  active: true,</span><br><span class="line">  &#x27;text-danger&#x27;: false</span><br><span class="line">&#125;)</span><br><span class="line">// .html</span><br><span class="line">&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>渲染结果与上面相同</strong></p>
<h4 id="在组件上使用类型绑定"><a href="#在组件上使用类型绑定" class="headerlink" title="在组件上使用类型绑定"></a>在组件上使用类型绑定</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 子组件模板 --&gt;</span><br><span class="line">&lt;p class=&quot;foo bar&quot;&gt;Hi!&lt;/p&gt;</span><br><span class="line">&lt;!-- 在使用组件时 --&gt;</span><br><span class="line">&lt;MyComponent class=&quot;baz boo&quot; /&gt;</span><br><span class="line">&lt;!--渲染出的 HTML 为：--&gt;</span><br><span class="line">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi!&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h3 id="绑定内敛样式"><a href="#绑定内敛样式" class="headerlink" title="绑定内敛样式"></a>绑定内敛样式</h3><p><strong>绑定对象</strong><br><code>:style</code>支持绑定 JavaScript 对象值，对应的是 HTML 元素的 <code>style</code>属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const activeColor = ref(&#x27;red&#x27;)</span><br><span class="line">const fontSize = ref(30)</span><br></pre></td></tr></table></figure>

<p><strong>你可以对一个样式属性提供多个 (不同前缀的) 值，举例来说：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>**数组仅会渲染浏览器支持的最后一个值。在这个示例中，在支持不需要特别前缀的浏览器中都会渲染为 **<code>display: flex</code>。</p>
<h3 id="渲染列表"><a href="#渲染列表" class="headerlink" title="渲染列表"></a>渲染列表</h3><p>**在 Vue 中，当使用 **<code>v-for</code> 渲染列表时，必须为每个迭代的元素绑定一个唯一的 <strong><code>key</code></strong> 属性。ESLint 的 <code>vue/require-v-for-key</code> 规则会强制检查这一点，目的是确保 Vue 的虚拟 DOM Diff 算法能正确识别和高效更新节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">  &#123;&#123; item.id &#125;&#125;:&#123;&#123; item.message &#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p><code>v-if</code> 、<code>v-else-if</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;</span><br><span class="line">  B</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Not A/B/C</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>这里，</strong><code>v-if</code> 指令会基于表达式 <code>seen</code> 的值的真假来移除&#x2F;插入该 <code>&lt;p&gt;</code> 元素。</p>
<p>**你也可以使用 **<code>v-else</code> 为 <code>v-if</code> 添加一个“else 区块”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button @click=&quot;awesome = !awesome&quot;&gt;Toggle&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-else</code> 和 <code>v-else-if</code> 也可以在 <code>&lt;template&gt;</code> 上使用。</p>
<p><code>v-show</code></p>
<p>**不同之处在于 **<code>v-show</code> 会在 DOM 渲染中保留该元素；<code>v-show</code> 仅切换了该元素上名为 <code>display</code> 的 CSS 属性。</p>
<p><code>v-show</code> 不支持在 <code>&lt;template&gt;</code> 元素上使用，也不能和 <code>v-else</code> 搭配使用。</p>
<p><code>v-show</code> VS <code>v-if</code></p>
<p><code>v-if</code> 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。</p>
<p><code>v-if</code> 也是<strong>惰性</strong>的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。</p>
<p><strong>相比之下，</strong><code>v-show</code> 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS <code>display</code> 属性会被切换。</p>
<p><strong>总的来说，</strong><code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 <code>v-show</code> 较好；如果在运行时绑定条件很少改变，则 <code>v-if</code> 会更合适。</p>
<blockquote>
<p>**当 **<code>v-if</code> 和 <code>v-for</code> 同时存在于一个元素上的时候，<code>v-if</code> 会首先被执行。</p>
</blockquote>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><code>v-on</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 简写 --&gt;</span><br><span class="line">&lt;a @click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-on</code> 指令，它将监听 DOM 事件</p>
<h3 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h3><p><strong>看上去像是自定义模板的 id</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, useTemplateRef, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const list = ref([</span><br><span class="line">  /* ... */</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">// 获取模板ref为items的dom元素</span><br><span class="line">const itemRefs = useTemplateRef(&#x27;items&#x27;)</span><br><span class="line">// 当模板被加载时打印获取的dom元素</span><br><span class="line">onMounted(() =&gt; console.log(itemRefs.value))</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">	&lt;!-- 给模板加ref标签 --&gt;</span><br><span class="line">    &lt;li v-for=&quot;item in list&quot; ref=&quot;items&quot;&gt;</span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p><strong>……</strong></p>
<h2 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h2><p><strong>声明响应式状态</strong></p>
<p>**在组合式 API 中，推荐使用 **<a href="https://cn.vuejs.org/api/reactivity-core.html#ref"><code>ref()</code></a> 函数来声明响应式状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const count = ref(0)</span><br></pre></td></tr></table></figure>

<p><code>ref()</code> 接收参数，并将其包裹在一个带有 <code>.value</code> 属性的 ref 对象中返回：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const count = ref(0)</span><br><span class="line"></span><br><span class="line">console.log(count) // &#123; value: 0 &#125;</span><br><span class="line">console.log(count.value) // 0</span><br><span class="line"></span><br><span class="line">count.value++</span><br><span class="line">console.log(count.value) // 1</span><br></pre></td></tr></table></figure>

<p><strong>注意，在模板中使用 ref 时，我们不需要附加 .value。为了方便起见，当在模板中使用时，ref 会自动解包 。</strong></p>
<h3 id="深层响应性"><a href="#深层响应性" class="headerlink" title="深层响应性"></a>深层响应性</h3><p><strong>Ref 可以持有任何类型的值，包括深层嵌套的对象、数组或者 JavaScript 内置的数据结构</strong></p>
<p><strong>Ref 会使它的值具有深层响应性。这意味着即使改变嵌套对象或数组时，变化也会被检测到：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const obj = ref(&#123;</span><br><span class="line">  nested: &#123; count: 0 &#125;,</span><br><span class="line">  arr: [&#x27;foo&#x27;, &#x27;bar&#x27;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function mutateDeeply() &#123;</span><br><span class="line">  // 以下都会按照期望工作</span><br><span class="line">  obj.value.nested.count++</span><br><span class="line">  obj.value.arr.push(&#x27;baz&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>也可以通过 shallow ref 来放弃深层响应性。对于浅层 ref，只有 .value 的访问会被追踪。浅层 ref 可以用于避免对大型数据的响应性开销来优化性能、或者有外部库管理其内部状态的情况。</strong></p>
<hr>
<p>**还有另一种声明响应式状态的方式，即使用 **<code>reactive()</code> API。与将内部值包装在特殊对象中的 ref 不同，<code>reactive()</code> 将使对象本身具有响应性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const state = reactive(&#123; count: 0 &#125;)</span><br></pre></td></tr></table></figure>

<p><code>reactive()</code> 的局限性</p>
<p><strong>1.有限的值类型：它只能用于对象类型 (对象、数组和如 Map、Set 这样的集合类型)。它不能持有如 string、number 或 boolean 这样的原始类型。</strong></p>
<p><strong>2.不能替换整个对象：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失：</strong></p>
<p><strong>3.对解构操作不友好：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let state = reactive(&#123; count: 0 &#125;)</span><br><span class="line"></span><br><span class="line">// 上面的 (&#123; count: 0 &#125;) 引用将不再被追踪</span><br><span class="line">// (响应性连接已丢失！)</span><br><span class="line">state = reactive(&#123; count: 1 &#125;)</span><br><span class="line"></span><br><span class="line">const state = reactive(&#123; count: 0 &#125;)</span><br><span class="line"></span><br><span class="line">// 当解构时，count 已经与 state.count 断开连接</span><br><span class="line">let &#123; count &#125; = state</span><br><span class="line">// 不会影响原始的 state</span><br><span class="line">count++</span><br><span class="line"></span><br><span class="line">// 该函数接收到的是一个普通的数字</span><br><span class="line">// 并且无法追踪 state.count 的变化</span><br><span class="line">// 我们必须传入整个对象以保持响应性</span><br><span class="line">callSomeFunction(state.count)</span><br></pre></td></tr></table></figure>

<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>**推荐使用****计算属性**来描述依赖响应式状态的复杂逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, computed &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const author = reactive(&#123;</span><br><span class="line">  name: &#x27;John Doe&#x27;,</span><br><span class="line">  books: [</span><br><span class="line">    &#x27;Vue 2 - Advanced Guide&#x27;,</span><br><span class="line">    &#x27;Vue 3 - Basic Guide&#x27;,</span><br><span class="line">    &#x27;Vue 4 - The Mystery&#x27;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 一个计算属性 ref</span><br><span class="line">const publishedBooksMessage = computed(() =&gt; &#123;</span><br><span class="line">  return author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;Has published books:&lt;/p&gt;</span><br><span class="line">  &lt;span&gt;&#123;&#123; publishedBooksMessage &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p><strong>我们在这里定义了一个计算属性 publishedBooksMessage。computed() 方法期望接收一个 getter 函数，返回值为一个计算属性 ref。和其他一般的 ref 类似，你可以通过 publishedBooksMessage.value 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 .value。</strong></p>
<p>**Vue 的计算属性会自动追踪响应式依赖。它会检测到 **<code>publishedBooksMessage</code> 依赖于 <code>author.books</code>，所以当 <code>author.books</code> 改变时，任何依赖于 <code>publishedBooksMessage</code> 的绑定都会同时更新。</p>
<h3 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; calculateBooksMessage() &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p><strong>你可能注意到我们在表达式中像这样调用一个函数也会获得和计算属性相同的结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 组件中</span><br><span class="line">function calculateBooksMessage() &#123;</span><br><span class="line">  return author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于 ****计算属性值会基于其响应式依赖被缓存** 。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 <code>author.books</code> 不改变，无论多少次访问 <code>publishedBooksMessage</code> 都会立即返回先前的计算结果，而不用重复执行 getter 函数。</p>
<p>**这也解释了为什么下面的计算属性永远不会更新，因为 **<code>Date.now()</code> 并不是一个响应式依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const now = computed(() =&gt; Date.now())</span><br></pre></td></tr></table></figure>

<p>**相比之下，方法调用****总是**会在重渲染发生时再次执行函数。</p>
<p><strong>为什么需要缓存呢？如果没有缓存，多次调用一个庞大的数据是非常消耗内存资源的。</strong></p>
<h3 id="可写计算属性"><a href="#可写计算属性" class="headerlink" title="可写计算属性"></a>可写计算属性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computer(&#123;</span><br><span class="line">get() &#123;</span><br><span class="line">// getter方法实现</span><br><span class="line">// return</span><br><span class="line">&#125;</span><br><span class="line">set()&#123;</span><br><span class="line">// setter方法实现</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>**计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说， ****不要改变其他状态、在 getter 中做异步请求或者更改 DOM** ！</p>
<p><strong>从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。</strong></p>
<h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><p><strong>在前端处理表单时，我们常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。手动连接值绑定和更改事件监听器可能会很麻烦：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  :value=&quot;text&quot;</span><br><span class="line">  @input=&quot;</span><br><span class="line">    (event) =&gt;</span><br><span class="line">      (text = (event.target as HTMLInputElement).value)</span><br><span class="line">  &quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-model</code> 指令帮我们简化了这一步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=&quot;text&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p><strong>当某一变量值发生改变，在每次响应式状态发生变化时触发回调函数。</strong></p>
<p><code>watch</code> 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const x = ref(0)</span><br><span class="line">const y = ref(0)</span><br><span class="line"></span><br><span class="line">// 单个 ref</span><br><span class="line">watch(x, (newX) =&gt; &#123;</span><br><span class="line">  console.log(`x is $&#123;newX&#125;`)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// getter 函数</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; x.value + y.value,</span><br><span class="line">  (sum) =&gt; &#123;</span><br><span class="line">    console.log(`sum of x + y is: $&#123;sum&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 多个来源组成的数组</span><br><span class="line">watch([x, () =&gt; y.value], ([newX, newY]) =&gt; &#123;</span><br><span class="line">  console.log(`x is $&#123;newX&#125; and y is $&#123;newY&#125;`)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意，你不能直接侦听响应式对象的属性值，例如:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = reactive(&#123; count: 0 &#125;)</span><br><span class="line"></span><br><span class="line">// 错误，因为 watch() 得到的参数是一个 number</span><br><span class="line">watch(obj.count, (count) =&gt; &#123;</span><br><span class="line">  console.log(`Count is: $&#123;count&#125;`)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>这里需要用一个返回该属性的 getter 函数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 提供一个 getter 函数</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; obj.count,</span><br><span class="line">  (count) =&gt; &#123;</span><br><span class="line">    console.log(`Count is: $&#123;count&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>**默认状态 **<code>watch</code>会创建一个深层次监听对象，使用 <code>&#123;deep:true&#125;</code>显示创建深层次 <code>watch</code></p>
<p><code>watchEffect()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const todoId = ref(1)</span><br><span class="line">const data = ref(null)</span><br><span class="line"></span><br><span class="line">watch(</span><br><span class="line">  todoId,</span><br><span class="line">  async () =&gt; &#123;</span><br><span class="line">    const response = await fetch(</span><br><span class="line">      `https://jsonplaceholder.typicode.com/todos/$&#123;todoId.value&#125;`</span><br><span class="line">    )</span><br><span class="line">    data.value = await response.json()</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; immediate: true &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>**可以使用 **<code>watchEffect()</code>简写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watchEffect(async () =&gt; &#123;</span><br><span class="line">  const response = await fetch(</span><br><span class="line">    `https://jsonplaceholder.typicode.com/todos/$&#123;todoId.value&#125;`</span><br><span class="line">  )</span><br><span class="line">  data.value = await response.json()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>**每当 **<code>todoId.value</code> 变化时，回调会再次执行。有了 <code>watchEffect()</code>，我们不再需要明确传递 <code>todoId</code> 作为源值。</p>
<p><strong>对于这种只有一个依赖项的例子来说，</strong><code>watchEffect()</code> 的好处相对较小。但是对于有多个依赖项的侦听器来说，使用 <code>watchEffect()</code> 可以消除手动维护依赖列表的负担。此外，如果你需要侦听一个嵌套数据结构中的几个属性，<code>watchEffect()</code> 可能会比深度侦听器更有效，因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。</p>
<p><strong>另外，</strong><code>watchEffect()</code>会立刻执行一次。</p>
<hr>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><strong>注册组件</strong></p>
<p><strong>组件名格式：</strong><code>PascalCase</code> 作为组件名的注册格式</p>
<p><code>&lt;PascalCase /&gt;</code> 在模板中更明显地表明了这是一个 Vue 组件，而不是原生 HTML 元素。同时也能够将 Vue 组件和自定义元素 (web components) 区分开来。</p>
<p>**为了方便，Vue 支持将模板中使用 kebab-case 的标签解析为使用 PascalCase 注册的组件。这意味着一个以 **<code>MyComponent</code> 为名注册的组件，在模板 (或由 Vue 渲染的 HTML 元素) 中可以通过 <code>&lt;MyComponent&gt;</code> 或 <code>&lt;my-component&gt;</code> 引用。</p>
<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p><strong>具名插槽</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--父组件--&gt;</span><br><span class="line">&lt;HomeView&gt;</span><br><span class="line">  // 具名插槽简写</span><br><span class="line">  &lt;template #header&gt;点我&lt;/template&gt;</span><br><span class="line">  // 具名插槽全称</span><br><span class="line">  &lt;template v-slot:main&gt;content&lt;/template&gt;</span><br><span class="line">&lt;/HomeView&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  // 条件插槽,如果该div下有名为header的插槽时候，才会显示</span><br><span class="line">  &lt;div v-if=&quot;$slots.header&quot;&gt;</span><br><span class="line">    &lt;button&gt;&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button&gt;&lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p><strong>作用域插槽</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--父组件--&gt;</span><br><span class="line">&lt;HomeView&gt;</span><br><span class="line">  // #header=&quot;&#123; massage &#125;作用为接受slot传送参数</span><br><span class="line">  &lt;template #header=&quot;&#123; massage &#125;&quot;&gt; &#123;&#123; massage &#125;&#125; &lt;/template&gt;</span><br><span class="line">&lt;/HomeView&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--子组件--&gt;</span><br><span class="line">  &lt;div id=&quot;HomeView&quot;&gt;</span><br><span class="line">    &lt;button&gt;</span><br><span class="line">// 传递参数massage</span><br><span class="line">      &lt;slot name=&quot;header&quot; massage=&quot;hello&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p><strong>作用域插槽实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--父组件--&gt;</span><br><span class="line">&lt;HomeView&gt;</span><br><span class="line">  &lt;template #item=&quot;&#123; item &#125;&quot;&gt;</span><br><span class="line">    &#123;&#123; item.id &#125;&#125; : &#123;&#123; item.name &#125;&#125;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/HomeView&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--子组件--&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">    &lt;!--v-bind 来传递插槽的 props--&gt;</span><br><span class="line">    &lt;slot name=&quot;item&quot; :item&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p><strong>有些场景会需要在两个组件间来回切换，比如 Tab 界面</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;demo&quot;&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        v-for=&quot;(item, tab) in tabs&quot;</span><br><span class="line">        :key=&quot;tab&quot;</span><br><span class="line">        @click=&quot;currentTab = tab&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &#123;&#123; tab &#125;&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;component :is=&quot;tabs[currentTab]&quot;&gt;&lt;/component&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  import Home from &#x27;@/components/HomeView.vue&#x27;</span><br><span class="line">  import About from &#x27;@/components/AboutView.vue&#x27;</span><br><span class="line">  import &#123; ref, type Component &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  // 强制声明为动态键对象，并不是一个数组，而是一个对象（Object）。</span><br><span class="line">  // 它的类型会根据 Home 和 About 的具体类型自动推断。</span><br><span class="line">  const tabs: Record&lt;string, Component&gt; = &#123;</span><br><span class="line">    Home,</span><br><span class="line">    About,</span><br><span class="line">  &#125;</span><br><span class="line">  const currentTab = ref(&#x27;Home&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p><strong>传递 props：名字格式 camelCase</strong></p>
<p>**所有的 props 都遵循着****单向绑定**原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。</p>
<p>**另外，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，这意味着你****不应该**在子组件中去更改一个 prop。若你这么做了，Vue 会在控制台上向你抛出警告：<code>警告！prop 是只读的！</code></p>
<p><strong>你可以在子组件中定义一个局部变量，从 props 中获取数据的值，或者定义一个计算属性，依靠父组件传递的 props 而改变</strong></p>
<p>**在使用 **<code>&lt;script setup&gt;</code> 的单文件组件中，props 可以使用 <code>defineProps()</code> 宏来声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps([&#x27;foo&#x27;])</span><br><span class="line"></span><br><span class="line">console.log(props.foo)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>除了使用字符串数组来声明 props 外，还可以使用对象的形式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用 &lt;script setup&gt;</span><br><span class="line">defineProps(&#123;</span><br><span class="line">  title: String,</span><br><span class="line">  likes: Number,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>**如果你正在搭配 TypeScript 使用 **<code>&lt;script setup&gt;</code>，也可以使用类型标注来声明 props</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  defineProps&lt;&#123;</span><br><span class="line">    title?: string</span><br><span class="line">    likes?: number</span><br><span class="line">  &#125;&gt;()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>**当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但仍然****可以**更改对象或数组内部的值。这是因为 JavaScript 的对象和数组是按引用传递，对 Vue 来说，阻止这种更改需要付出的代价异常昂贵。</p>
<p><strong>这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。在最佳实践中，你应该尽可能避免这样的更改，除非父子组件在设计上本来就需要紧密耦合。</strong></p>
<h4 id="TS-解构语法"><a href="#TS-解构语法" class="headerlink" title="TS 解构语法"></a>TS 解构语法</h4><p><strong>1. 对象解构</strong></p>
<p><strong>基础解构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义对象</span><br><span class="line">const user = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  age: 30,</span><br><span class="line">  email: &#x27;alice@example.com&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解构并添加类型注解</span><br><span class="line">const &#123; name, age &#125;: &#123; name: string; age: number &#125; = user</span><br><span class="line"></span><br><span class="line">console.log(name) // &quot;Alice&quot;</span><br><span class="line">console.log(age) // 30</span><br></pre></td></tr></table></figure>

<p><strong>重命名 + 默认值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123; name: userName, role = &#x27;guest&#x27; &#125; = user</span><br><span class="line">// userName: string, role: string（默认值为 &quot;guest&quot;）</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 数组解构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义数组</span><br><span class="line">const numbers = [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">// 解构并添加类型注解</span><br><span class="line">const [first, second]: [number, number] = numbers</span><br><span class="line"></span><br><span class="line">console.log(first) // 1</span><br><span class="line">console.log(second) // 2</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>3. 函数参数解构</strong></p>
<p><strong>对象参数解构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解构参数并指定类型</span><br><span class="line">function printUser(&#123; name, age &#125;: User) &#123;</span><br><span class="line">  console.log(`$&#123;name&#125; is $&#123;age&#125; years old`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printUser(&#123; name: &#x27;Bob&#x27;, age: 25 &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h3><h4 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h4><p><strong>监听事件：父组件文件</strong></p>
<p><strong>方法 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;HomeView @increace-by=&quot;increaceBy&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// ts</span><br><span class="line">function increaceBy() &#123;</span><br><span class="line">  count.value += 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;HomeView @increace-by=&quot;(n) =&gt; (count += 1)&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>触发事件：子组件文件</strong></p>
<p><strong>配合方法 1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line">    &lt;button @click=&quot;emit(&#x27;increaceBy&#x27;, 1)&quot;&gt;</span><br><span class="line">      increace By 1</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">// ts</span><br><span class="line">const emit = defineEmits([&#x27;increaceBy&#x27;])</span><br></pre></td></tr></table></figure>

<p><strong>配合方法 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button @click=&quot;$emit(&#x27;increaceBy&#x27;, 1)&quot;&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h4 id="事件校验"><a href="#事件校验" class="headerlink" title="事件校验"></a>事件校验</h4><p><strong>存疑处…..</strong></p>
<h3 id="组件-v-model"><a href="#组件-v-model" class="headerlink" title="组件 v-model"></a>组件 v-model</h3><p><strong>原理实现 3.4 以前</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//父组件</span><br><span class="line">    &lt;HomeView</span><br><span class="line">// 单项传递值</span><br><span class="line">      :modelValue=&quot;value&quot;</span><br><span class="line">// 监听事件，并且更新传递值</span><br><span class="line">      @update:modelValue=&quot;($event) =&gt; (value = $event)&quot;</span><br><span class="line">    /&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;HomeView&quot;&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">// 绑定单向值</span><br><span class="line">      :value=&quot;props.modelValue&quot;</span><br><span class="line">// 触发事件</span><br><span class="line">      @input=&quot;</span><br><span class="line">        emit(</span><br><span class="line">          &#x27;update:modelValue&#x27;,</span><br><span class="line">          ($event.target as HTMLInputElement).value,</span><br><span class="line">        )</span><br><span class="line">      &quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">const props = defineProps([&#x27;modelValue&#x27;])</span><br><span class="line">const emit = defineEmits([&#x27;update:modelValue&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>简化实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// html</span><br><span class="line">    &lt;HomeView v-model=&quot;value&quot; /&gt;&lt;template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div id=&quot;HomeView&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;updata&quot;&gt;&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">// ts</span><br><span class="line">const model = defineModel(&#123; default: 1 &#125;)</span><br><span class="line">function updata() &#123;</span><br><span class="line">  model.value++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="透传属性"><a href="#透传属性" class="headerlink" title="透传属性"></a>透传属性</h3><p>**“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或者 **<code>v-on</code> 事件监听器。最常见的例子就是 <code>class</code>、<code>style</code> 和 <code>id</code>。</p>
<h4 id="禁用透传属性"><a href="#禁用透传属性" class="headerlink" title="禁用透传属性"></a>禁用透传属性</h4><p>**如果你****不想要**一个组件自动地继承 attribute，你可以在组件选项中设置 <code>inheritAttrs: false</code>。从 3.3 开始你也可以直接在 <code>&lt;script setup&gt;</code> 中使用 <a href="https://cn.vuejs.org/api/sfc-script-setup.html#defineoptions"><code>defineOptions</code></a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">defineOptions(&#123;</span><br><span class="line">  inheritAttrs: false</span><br><span class="line">&#125;)</span><br><span class="line">// ...setup 逻辑</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>**这些透传进来的 attribute 可以在模板的表达式中直接用 **<code>$attrs</code> 访问到。</p>
<h4 id="多根节点继承问题"><a href="#多根节点继承问题" class="headerlink" title="多根节点继承问题"></a>多根节点继承问题</h4><p>**和单根节点组件有所不同，有着多个根节点的组件没有自动 attribute 透传行为。如果 **<code>$attrs</code> 没有被显式绑定，将会抛出一个运行时警告。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;CustomLayout id=&quot;custom-layout&quot; @click=&quot;changeValue&quot; /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;header&gt;...&lt;/header&gt;</span><br><span class="line">&lt;main&gt;...&lt;/main&gt;</span><br><span class="line">&lt;footer&gt;...&lt;/footer&gt;</span><br></pre></td></tr></table></figure>

<p>**如果 **<code>$attrs</code> 被显式绑定，则不会有警告：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;header&gt;...&lt;/header&gt;</span><br><span class="line">&lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class="line">&lt;footer&gt;...&lt;/footer&gt;</span><br></pre></td></tr></table></figure>

<p>**如果需要，你可以在 **<code>&lt;script setup&gt;</code> 中使用 <code>useAttrs()</code> API 来访问一个组件的所有透传 attribute：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useAttrs &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const attrs = useAttrs()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><strong>父组件向自己的祖孙组件传递数据，若使用 props 则会逐级透传，但是中间组件根本不关心这些数据，</strong><code>provide</code> 和 <code>inject</code> 可以帮助我们解决这一问题。一个父组件相对于其所有的后代组件，会作为 <strong>依赖提供者</strong> 。任何后代的组件树，无论层级有多深，都可以<strong>注入</strong>由父组件提供给整条链路的依赖。</p>
<h2 id="闭包理解"><a href="#闭包理解" class="headerlink" title="闭包理解"></a>闭包理解</h2><p><strong>函数闭包：维护函数内变量，函数返回值是一个函数。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const add = (function () &#123;</span><br><span class="line">  let count = 0</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return (count += 1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h2 id="Pinia-全局状态管理"><a href="#Pinia-全局状态管理" class="headerlink" title="Pinia 全局状态管理"></a>Pinia 全局状态管理</h2><p>**Store (如 Pinia) 是一个保存状态和业务逻辑的实体，它并不与你的组件树绑定。换句话说， **<strong>它承载着全局状态</strong> 。它有点像一个永远存在的组件，每个组件都可以读取和写入它。它有 **三个概念** state、getter、action</p>
<p><strong>引入:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; createPinia &#125; from &#x27;pinia&#x27;</span><br><span class="line">const pinia = createPinia()</span><br><span class="line">app.use(pinia)</span><br></pre></td></tr></table></figure>

<p><strong>定义 Store</strong></p>
<p><strong>在深入研究核心概念之前，我们得知道 Store 是用 <strong><code>defineStore()</code> 定义的，它的第一个参数要求是一个</strong>独一无二的</strong>名字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; defineStore &#125; from &#x27;pinia&#x27;</span><br><span class="line"></span><br><span class="line">// 你可以任意命名 `defineStore()` 的返回值，但最好使用 store 的名字，同时以 `use` 开头且以 `Store` 结尾。</span><br><span class="line">// (比如 `useUserStore`，`useCartStore`，`useProductStore`)</span><br><span class="line">// 第一个参数是你的应用中 Store 的唯一 ID。</span><br><span class="line">export const useAlertsStore = defineStore(&#x27;alerts&#x27;, &#123;</span><br><span class="line">  // 其他配置...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>**这个***<em>名字*</em> ，也被用作 <em>id</em> ，是必须传入的， Pinia 将用它来连接 store 和 devtools。为了养成习惯性的用法，将返回的函数命名为 *use…* 是一个符合组合式函数风格的约定。</p>
<p><code>defineStore()</code> 的第二个参数可接受两类值：Setup 函数或 Option 对象。</p>
<p><strong>选项式 store：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export const useCounterStore = defineStore(&#x27;counter&#x27;, &#123;</span><br><span class="line">  state: () =&gt; (&#123; count: 0, name: &#x27;Eduardo&#x27; &#125;),</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount: (state) =&gt; state.count * 2,</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>组合式 store</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export const useCounterStore = defineStore(&#x27;counter&#x27;, () =&gt; &#123;</span><br><span class="line">  const count = ref(0)</span><br><span class="line">  const doubleCount = computed(() =&gt; count.value * 2)</span><br><span class="line">  function increment() &#123;</span><br><span class="line">    count.value++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123; count, doubleCount, increment &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>**在 ***Setup Store* 中：</p>
<ul>
<li><code>ref()</code> 就是 <code>state</code> 属性</li>
<li><code>computed()</code> 就是 <code>getters</code></li>
<li><code>function()</code> 就是 <code>actions</code></li>
</ul>
<h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h2><ul>
<li><strong>查询字符串传参 Vs 路径传参</strong></li>
<li><strong>命名路由 Vs 别名路由</strong></li>
<li><strong>编程式导航</strong></li>
<li><strong>嵌套路由</strong></li>
<li><strong>路由重定向</strong></li>
<li><strong>路由守卫</strong></li>
<li><strong>命名视图</strong></li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
      </tags>
  </entry>
</search>
